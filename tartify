#!/bin/bash
##################################################################################
#
#       Filename:  tartify
#
#    Description:  BASH PS1 with GIT support
#
#                  Colored command prompt adapted to GIT repository. VERY
#                  colorfull, not for the faint hearted
#
#  Configuration:  place this file somewhere in your PATH and source it in your
#                  .bashrc
#
#                     source /path/to/bashps1
#
#   Dependencies:  Depends on GIT, might work on windows with Cygwin
#
#   GVIM Version:  1.7+ (?)
#
#         Author:  Pierre Lhoste
#        Twitter:  http://twitter.com/peterhost
#
#        Version:  0.1
#        Created:  01.05.2011
#        License:  WTFPL V2
#
# DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE Version 2, December 2004
#
# Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
#
# Everyone is permitted to copy and distribute verbatim or modified
# copies of this license document, and changing it is allowed as long as
# the name is changed.
#
#            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE TERMS AND
#            CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
#
#  0. You just DO WHAT THE FUCK YOU WANT TO.
#
#------------------------------------------------------------------------------
#

# USAGE : Just call the tartify() function from the command line
#
#         You can also pass arguments to tartify() to make it display only
#         certain informations
#
#           tartify -h
#
# SEE ALSO :
#
#           tartitune : tune tartify settings (colors, styles, ...)
#
#           tartiforce : temporarilly force tartify output
#

#PS1="${__PS1NN_}${__PS1EMK_}[${__PS1UC_}\u${__PS1EMK_}@${__PS1EMUC_}\h ${__PS1C_}\${NEW_PWD}${__PS1EMK_}] \$"
#PROMPT_COMMAND=tartify
#
#
#
#------------------------------------------------------------------------------
#
# ISSUE :
#

#   * conditionnal newline : if you need a multiline prompt, with the 'tartify'
#   line only inserted if you're being in a 'git' repository, consider using a
#   PROMPT_COMMAND like this :
#
#     prompt_command(){
#       ...
#       tartify w
#     }
#     PROMPT_COMMAND=prompt_command
#
#   The 'w' option to tartify issues a newline if the contents of \`tartify\`
#   is not an empty string.
#
#   ISSUE: Inside PS1, it will work too at the cost of inserting an extra
#   whitespace after the newline (otherwise the newline will be striped)
#
#
#      ALMOST WORKS :
#      PS1='$(echo -ne "\n ")\[$(tput kbs)$\] '
#
#      INDENTATION
#      PS1='\[$(tput sc)\]\[\033[60C (`date "+%a, %b %d"`)\]\[$(tput rc)\]'
#
#
#
#   * Line Wrapping Calculation
#
#     The one thing (that I know of) which confuse line wrapping (when browsing
#     command history with long lines, for ex) is non-printable characters
#     (such as ansi escape color codes, cursor movement,...). So:
#
#       1 - non-printable characters in the PS1 variable have to be "escaped"
#       by enclosing them between a pair of escaped brackets :
#
#           \[\033[0;30m\]   instead of  \033[0;30m
#
#       And this has to be done at PS1 definition-time, as PS1 is only assigned
#       ONCE but evaluated at EACH PROMPT.
#
#       2 - function calls inside the PS1 variable that issue non-printable
#       characters will confuse the prompt, naturally, if the said n-p-chars
#       are not escaped IN the PS1 variable itself at assignement time. Example :
#
#               PS1=">"
#               > pwd
#               /some/dir
#               > myfunc(){ echo  "\[\033[0;30m\]\$(pwd) > \[\033[0m\]"; }
#               > myfunc
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#
#           this will work
#               > PS1=$(myfunc)
#               /some/dir > echo $PS1
#               \[\033[0;30m\]$(pwd) > \[\033[0m\]
#               /some/dir > cd tmp
#               /some/dir/tmp >
#
#            this won't:
#               /some/dir/tmp > PS1='$(myfunc)'
#               \[\]stevejobs~ echo $PS1
#               $(myfunc)

#            As you can see in the latter, there are no escaped ansi codes
#            whatsoever, just a function call.  the prompt will print
#            litterally '\[\033[0;30m\]' each time, as this escaped substring
#            was not hardcoded in the PS1 variable at the time when it was
#            assigned, but generated by a function call evaluated for each
#            prompt, INSIDE the PS1 variable

#       MORE: on the subject
#       http://www.issociate.de/board/post/481503/bash_command_substitution,_functions_and_quoting_:_need_help.html
#
#     Problem is : if a function used in the PS1 variable is to adapt it's colored
#                  output according to context, there is no way to hardcode that
#                  directly in $PS1 with the '\[' escapes.
#
#       -> better use `printf` rather than `echo` (which somewhat sucks and which
#       behaviour is inconsistant across shells and OSes)
#
#       OR...
#       -> need to be issued on a line prior to the last line of the prompt, with :
#           * either \n insertion,
#
#               PS1="\$(tartify)\n$ "
#
#           * or use of the PROMPT_COMMAND environment variable
#
#               __somefunc() {
#                 ...
#                 tartify
#                 ...
#               }
#               export PROMPT_COMMAND=__somefunc
#               PS1=...
#
#       otherwise they will confuse wrapping too. Hence, your PS1 better look
#       something like :
#
#
#
#       (SEE:http://hintsforums.macworld.com/archive/index.php/t-17068.html)
#
#    * Quick n dirty benchmark
#      loop over 1000 executions of `tartify` on a 3.06GHz Intel Core 2 Duo Imac
#      without any further methodology
#
#       **execution-time (ms)**
#       _____________________________________________________________
#      |    REPO   | TINY       | SMALL     | MEDIUM    | LARGE      |
#      |           | ms   %     | ms   %    | ms   %    | ms   %     |
#      |___________|____________|___________|___________|____________|
#      |    remote | 48   25%   | 59   29%  | 92   27%  | 93  23%    |
#      |   1 stash | 56   30%   | 56   28%  | 179  52%  | 202 50%    |
#      |    branch | 60   32%   | 63   31%  | 46   13%  | 81  20%    |
#      |      repo | 14    7%   | 13    6%  | 13    4%  | 14   3%    |
#      |  timelast | 11    6%   | 11    5%  | 12    3%  | 12   3%    |
#      |           |            |           |           |            |
#      |     total | 189        | 202       | 342       | 402        |
#      |           |            |           |           |            |
#      | __git_ps1 |            |           |           | 63         |
#      | __git_ps1 |            |           |           |            |
#      |shwupstream|            |           | 21        | 26         |
#      |___________|____________|___________|___________|____________|
#
#
#------------------------------------------------------------------------------
#
# NOTA :
#          Special Character Codes
#          \a – an ASCII bell character (07)
#          \d – the date in “Weekday Month Date” format (e.g., “Tue May 26″)
#          \D{format} – the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required
#          \e – an ASCII escape character (033)  (hence : \e and \033 are equivalent)
#          \h – the hostname up to the first `.’
#          \H – the hostname
#          \j – the number of jobs currently managed by the shell
#          \l – the basename of the shell’s terminal device name
#          \n – newline
#          \r – carriage return
#          \s – the name of the shell, the basename of $0 (the portion following the final slash)
#          \t – the current time in 24-hour HH:MM:SS format
#          \T – the current time in 12-hour HH:MM:SS format
#          \@ – the current time in 12-hour am/pm format
#          \A – the current time in 24-hour HH:MM format
#          \u – the username of the current user
#          \v – the version of bash (e.g., 2.00)
#          \V – the release of bash, version + patchelvel (e.g., 2.00.0)
#          \w – the current working directory
#          \W – the basename of the current working directory
#          \! – the history number of this command
#          \# – the command number of this command
#          \$ – if the effective UID is 0, a #, otherwise a $
#          \nnn – the character corresponding to the octal number nnn
#          \\ – a backslash
#          \[ - begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt
#          \] – end a sequence of non-printing characters
#
#          (http://www.wiredrevolution.com/bash-programming/customize-the-bash-ps1-command-prompt)

#TODO:
#
# * WARN: problem with auto-separator (gitps1) with 'tartiforce qNBRSL'

#------------------------------------------------------------------------------
#
#             PRELIMINARY CHECKS
#
#------------------------------------------------------------------------------
# store command line params
__tartify_args="$*"

# Are we being sourced or executed ?
Prog="tartify"
__tartify_whocalled=
if [ "$(basename $0 2>/dev/null )" = "$Prog" ]; then
  __tartify_whocalled="exec"
else
  __tartify_whocalled="source"
fi

# take care of non UTF-8 terminals
supports8=
locale | grep -i utf-8 >/dev/null 2>&1 && supports8="true"


#------------------------------------------------------------------------------
#
#         SHELL DETECTION (not used for the moment, planned ZSH support)
#
#------------------------------------------------------------------------------

## SHELL detection
## SHELL      DARWIN      LINUX
## sh         path/to/sh  sh
## csh        -sh         -sh
## tcsh       -csh        -csh
## ksh        ksh         ksh
## bash       -bash       bash
## zsh        zsh         zsh

#__thisShell=`ps $$ | grep $$ | awk '{ print $5 }' | sed 's/\-/\\\-/g'`
#echo $__thisShell
#__thisShell=$(basename $__thisShell)
#echo $__thisShell
## Darwin detection
#if uname -s | grep "Darwin" >/dev/null 2>&1
#then
#  __OSflavor="Darwin" # macos
#fi

## BAIL if using SH on OSX, (scrambles "echo -ne" commands)
## (DEPRECATED, we use printf wherever possible)
#[ "$__OSflavor" = "Darwin" ] && [ "$__thisShell" = "sh" ] && { echo " SH detected, exit";  exit 1; }

#------------------------------------------------------------------------------
#
#             MISC GLOBAL VARIABLES
#
#------------------------------------------------------------------------------


__tartify_define_colors_TPUT() {
# COLOR VARS :  * declare those color codes ONCE and for ALL.
#                 This somewhat pollutes the GLOBAL SCOPE but the variable names
#                 are (thought to be) unique enough so that won't cause problems
#
#               * do that like a grownup (tput, not ANSI escapes)
#
#               * TODO: handle dark vs light background
#
#               * TODO: handle 256 colors (if [ $(tput colors) -ge 256 ] ...)
#                       -> do that via tartitheme()
#

#ONLY DO THAT if not done anywhere else before when sourcing `.bashrc`

if [ "true" = "$__TPUT_COLORS_DEFINED" ]; then : ; else

                                                                     #   ANSI equivalent
                                                                     #  <attr> <fg>  <bg>
  # ALL
   __NN_=$( tput sgr0   || : 2>/dev/null )                    # [ 0m                RESET ALL attributes

  # STYLES
  # <BEGIN>
   __EM_=$( tput bold    || : 2>/dev/null )                   # [ 1m                BEGIN DOUBLE INTENSITY (bold) mode
   __DM_=$( tput dim     || : 2>/dev/null )                   # [ 2m                BEGIN HALF INTENSITY    (dim) mode
   __UN_=$( tput smul    || : 2>/dev/null )                   # [ 4m                BEGIN UNDESCORE  (underlined) mode
   __BL_=$( tput blink   || : 2>/dev/null )                   # [ 5m                BEGIN BLINKING                mode
   __RV_=$( tput rev     || : 2>/dev/null )                   # [ 7m                BEGIN REVERSE VIDEO (reverse) mode
   __SO_=$( tput smso    || : 2>/dev/null )                   #?[ 7m                BEGIN STANDOUT      (reverse) mode
   __IN_=$( tput invis   || : 2>/dev/null )                   # [ 8m                BEGIN INVISIBLE               mode
   __DEL_=$(tput cub1    || : 2>/dev/null )                   #                     MOVE cursor LEFT one space
  # <END>
  __SOQ_=$( tput rmso    || : 2>/dev/null )                   #?[ 27m               END   STANDOUT      (reverse) mode
  __UNQ_=$( tput rmul    || : 2>/dev/null )                   # [ 24m               END   UNDESCORE  (underlined) mode
  # for all other END style, use `tput sgr0` ($__NN_)

  # COLORS
  # <Foreground>
    __K_=$( tput setf 0 || tput setaf 0 || : 2>/dev/null )    # [       0m          SET   FG color to BLACK
    __R_=$( tput setf 4 || tput setaf 1 || : 2>/dev/null )    # [       1m          SET   FG color to RED
    __G_=$( tput setf 2 || tput setaf 2 || : 2>/dev/null )    # [       2m          SET   FG color to GREEN
    __Y_=$( tput setf 6 || tput setaf 3 || : 2>/dev/null )    # [       3m          SET   FG color to YELLOW
    __B_=$( tput setf 1 || tput setaf 4 || : 2>/dev/null )    # [       4m          SET   FG color to BLUE
    __M_=$( tput setf 5 || tput setaf 5 || : 2>/dev/null )    # [       5m          SET   FG color to MAGENTA
    __C_=$( tput setf 3 || tput setaf 6 || : 2>/dev/null )    # [       6m          SET   FG color to CYAN
    __W_=$( tput setf 7 || tput setaf 7 || : 2>/dev/null )    # [       7m          SET   FG color to WHITE
  # <Background>
  __BGK_=$( tput setb 0 || tput setab 0 || : 2>/dev/null )    # [       0m          SET   BG color to BLACK
  __BGR_=$( tput setb 4 || tput setab 1 || : 2>/dev/null )    # [       1m          SET   BG color to RED
  __BGG_=$( tput setb 2 || tput setab 2 || : 2>/dev/null )    # [       2m          SET   BG color to GREEN
  __BGY_=$( tput setb 6 || tput setab 3 || : 2>/dev/null )    # [       3m          SET   BG color to YELLOW
  __BGB_=$( tput setb 1 || tput setab 4 || : 2>/dev/null )    # [       4m          SET   BG color to BLUE
  __BGM_=$( tput setb 5 || tput setab 5 || : 2>/dev/null )    # [       5m          SET   BG color to MAGENTA
  __BGC_=$( tput setb 3 || tput setab 6 || : 2>/dev/null )    # [       6m          SET   BG color to CYAN
  __BGW_=$( tput setb 7 || tput setab 7 || : 2>/dev/null )    # [       7m          SET   BG color to WHITE
  # <reset>
   __NF_=$( tput setf 9 || tput setaf 9 || : 2>/dev/null )    # [       39m         RESET FG color to term's default
   __NG_=$( tput setb 9 || tput setab 9 || : 2>/dev/null )    # [             49m   RESET BG color to term's default
  __NFG_=$__NF_$__NB_                                         # [       39;   49m   RESET FG & BG color to term's default

  if [ $(tput colors) -eq 256 ]; then
  ## <Foreground>
    __K_=$( tput setf 243 || tput setaf 243 || : 2>/dev/null ) #                    SET   FG color to BLACK
  #  __R_=$( tput setf 196 || tput setaf 196 || : 2>/dev/null ) #                    SET   FG color to RED
  #  __G_=$( tput setf 34  || tput setaf 34  || : 2>/dev/null ) #                    SET   FG color to GREEN
  #  __Y_=$( tput setf 220 || tput setaf 220 || : 2>/dev/null ) #                    SET   FG color to YELLOW
  #  __B_=$( tput setf 33  || tput setaf 33  || : 2>/dev/null ) #                    SET   FG color to BLUE
  #  __M_=$( tput setf 201 || tput setaf 201 || : 2>/dev/null ) #                    SET   FG color to MAGENTA
  #  __C_=$( tput setf 45  || tput setaf 45  || : 2>/dev/null ) #                    SET   FG color to CYAN
  #  __W_=$( tput setf 15  || tput setaf 15  || : 2>/dev/null ) #                    SET   FG color to WHITE
  ## <Background>
  #__BGK_=$( tput setb 243 || tput setab 243 || : 2>/dev/null ) #                    SET   BG color to BLACK
  #__BGR_=$( tput setb 196 || tput setab 196 || : 2>/dev/null ) #                    SET   BG color to RED
  #__BGG_=$( tput setb 34  || tput setab 34  || : 2>/dev/null ) #                    SET   BG color to GREEN
  #__BGY_=$( tput setb 220 || tput setab 220 || : 2>/dev/null ) #                    SET   BG color to YELLOW
  #__BGB_=$( tput setb 33  || tput setab 33  || : 2>/dev/null ) #                    SET   BG color to BLUE
  #__BGM_=$( tput setb 201 || tput setab 201 || : 2>/dev/null ) #                    SET   BG color to MAGENTA
  #__BGC_=$( tput setb 45  || tput setab 45  || : 2>/dev/null ) #                    SET   BG color to CYAN
  #__BGW_=$( tput setb 15  || tput setab 15  || : 2>/dev/null ) #                    SET   BG color to WHITE

  fi

  # <pseudo Foreground-bold>
  __EMK_=$__EM_$__K_                                          # [ 1;    20m         SET   FG color to BOLD BLACK
  __EMR_=$__EM_$__R_                                          # [ 1;    21m         SET   FG color to BOLD RED
  __EMG_=$__EM_$__G_                                          # [ 1;    22m         SET   FG color to BOLD GREEN
  __EMY_=$__EM_$__Y_                                          # [ 1;    23m         SET   FG color to BOLD YELLOW
  __EMB_=$__EM_$__B_                                          # [ 1;    24m         SET   FG color to BOLD BLUE
  __EMM_=$__EM_$__M_                                          # [ 1;    25m         SET   FG color to BOLD MAGENTA
  __EMC_=$__EM_$__C_                                          # [ 1;    26m         SET   FG color to BOLD CYAN
  __EMW_=$__EM_$__W_                                          # [ 1;    27m         SET   FG color to BOLD RED

  #MISC (non color)
  __NL_=$( tput cud1 )

fi

}


__tartify_reset_PS1_globs(){
  local section=$1

  if [ "NAME" = "$section" ] || [ -z "$section" ];then
     __t4_rep=""   # repo name
     __t4_nrep=""  # repo name with 'm/M' option
     __t4_lpath="" # local path in repo with 'm/M' option
    __t4_sepN=""   # dynamic separator for repo name
   __t4_ncrep=""   # NOCOLORS repo name
  fi

  if [ "BRANCH" = "$section" ] || [ -z "$section" ];then
      # T=untracked files    t=no untracked files
      # U=unstaged changes   u=no unstaged changes
      # S=staged changes     s=no staged changes
      # R=remote info        r=no remote info

      __t4_tU=""   #           Unstaged
      __t4_tuSr="" #           Staged                (stag-before-rem
      __t4_tRA=""  #           remote Ahead of
      __t4_tRD=""  #           remote behinD
      __t4_tRI=""  #           remote dIverged
      __t4_tRO=""  #           remote Ok (uptodate)
      __t4_tRN=""  #           remote None
      __t4_turS="" #           Staged                (stag-before-rem
      __t4_TU=""   #UNtracked  Unstaged
      __t4_TuSr="" #UNtracked  Staged                (stag-before-rem
      __t4_TRA=""  #UNtracked  remote Ahead of
      __t4_TRD=""  #UNtracked  remote behinD
      __t4_TRI=""  #UNtracked  remote dIverged
      __t4_TRO=""  #UNtracked  remote Ok (uptodate)
      __t4_TRN=""  #UNtracked  remote None
      __t4_TurS="" #UNtracked  Staged                (rem-before-stag

     __t4_sepB=""  # dynamic separator for branch
     __t4_merg=""  # merge infos for branch
     __t4_bare=""  # bare repository indicator
 __t4_ncbranch=""  # NOCOLORS branch
   __t4_ncmerg=""  # NOCOLORS merge infos for branch
   __t4_ncbare=""  # NOCOLORS bare repository indicator
__t4_oldschool=""  # OLDSCHOOL branch (__git_PS1)
  fi

  if [ "ANCESTOR" = "$section" ] || [ -z "$section" ];then

      __t4_anc=""  # name of parent repo in case of submodule

     __t4_sepA=""  # dynamic separator for ancestor
    __t4_ncanc=""  # NOCOLORS ancestor
  fi

  if [ "REMOTE" = "$section" ] || [ -z "$section" ];then
    __t4_sepR=""   # dynamic separator for remotes
    __t4_rOrsep="" # dynamic inter-remotes separator
    __t4_rOt=""    # tracked marker for remotename 'origin'
    __t4_rOn=""    # marker for remotename 'origin'
    __t4_rO1p=""   # first paren for count of commits ahead/behind of remote for remotename 'origin'
    __t4_rOac=""   # nb of commits ahead of remote for remotename 'origin'
    __t4_rOcsep="" # (optional) separator
    __t4_rObc=""   # nb of commits behind of remote for remotename 'origin'
    __t4_rO2p=""   # second paren for count of commits ahead/behind of remote for remotename 'origin'

    __t4_rUrsep="" # dynamic inter-remotes separator
    __t4_rUt=""    # tracked marker for remotename 'upstream'
    __t4_rUn=""    # marker for remotename 'upstream'
    __t4_rU1p=""   # first paren for count of commits ahead/behind of remote for remotename 'upstream'
    __t4_rUac=""   # nb of commits ahead of remote for remotename 'upstream'
    __t4_rUcsep="" # (optional) separator
    __t4_rUbc=""   # nb of commits behind of remote for remotename 'upstream'
    __t4_rU2p=""   # second paren for count of commits ahead/behind of remote for remotename 'upstream'

    __t4_r1rsep="" # dynamic inter-remotes separator
    __t4_r1t=""    # tracked marker for 1ST remotename 'other'
    __t4_r1n=""    # marker for 1ST remotename 'other'
    __t4_r11p=""   # first paren for count of commits ahead/behind of remote for 1ST remotename 'other'
    __t4_r1ac=""   # nb of commits ahead of remote for 1ST remotename 'other'
    __t4_r1csep="" # (optional) separator
    __t4_r1bc=""   # nb of commits behind of remote for 1ST remotename 'other'
    __t4_r12p=""   # second paren for count of commits ahead/behind of remote for 1ST remotename 'other'

    __t4_r2rsep="" # dynamic inter-remotes separator
    __t4_r2t=""    # tracked marker for 2ND remotename 'other'
    __t4_r2n=""    # marker for 2ND remotename 'other'
    __t4_r21p=""   # first paren for count of commits ahead/behind of remote for 2ND remotename 'other'
    __t4_r2ac=""   # nb of commits ahead of remote for 2ND remotename 'other'
    __t4_r2csep="" # (optional) separator
    __t4_r2bc=""   # nb of commits behind of remote for 2ND remotename 'other'
    __t4_r22p=""   # second paren for count of commits ahead/behind of remote for 2ND remotename 'other'

    __t4_r3rsep="" # dynamic inter-remotes separator
    __t4_r3t=""    # tracked marker for 3RD remotename 'other'
    __t4_r3n=""    # marker for 3RD remotename 'other'
    __t4_r31p=""   # first paren for count of commits ahead/behind of remote for 3RD remotename 'other'
    __t4_r3ac=""   # nb of commits ahead of remote for 3RD remotename 'other'
    __t4_r3csep="" # (optional) separator
    __t4_r3bc=""   # nb of commits behind of remote for 3RD remotename 'other'
    __t4_r32p=""   # second paren for count of commits ahead/behind of remote for 3RD remotename 'other'

    __t4_ncremotes="" # NOCOLORS remotes

  fi

  if [ "STASH" = "$section" ] || [ -z "$section" ];then
     __t4_st=""   # stash nocount
     __t4_ST=""   # stash count
   __t4_sepS=""   # dynamic separator for stashes
   __t4_ncstash="" # NOCOLORS stash no count
   __t4_ncSTASH="" # NOCOLORS stash count

  fi

  if [ "LAST" = "$section" ] || [ -z "$section" ];then
    __t4_sepL=""   # dynamic separator for time-last-commit
    __t4_lccan=""  # Could Commit Activity None
    __t4_lccal=""  # Could Commit Activity Low
    __t4_lccah=""  # Could Commit Activity High
    __t4_lscan=""  # Should Commit Activity None
    __t4_lscal=""  # Should Commit Activity Low
    __t4_lscah=""  # Should Commit Activity High
    __t4_lnhan=""  # No Hurry Activity None
    __t4_lnhal=""  # No Hurry Activity Low
    __t4_lnhah=""  # No Hurry Activity High

    __t4_nclast="" # NOCOLORS last

  fi


  [ -z "$section" ] && {
  #NOTA : all variables named __t4_D*, where * is one or more numbers
  #       are dynamically generated at `tartify` evaluation time
  #       (reserved variables for user-supplied delimiters)
  #        0-49 : reserved for COLORED prompt
  #       50-99 : reserved for NOCOLORS prompt (tartify 'c' option)
  #
  #       NB1: 50 delimiters should be plenty enough
  #       NB2: could have used loop
  #             for ((n=0;n<100;n++)); do eval "__t4_D$n=" ; done;
  #           but about 10 times slower

    __t4_D0=;     __t4_D1=;     __t4_D2=;     __t4_D3=;     __t4_D4=;
    __t4_D5=;     __t4_D6=;     __t4_D7=;     __t4_D8=;     __t4_D9=;
    __t4_D10=;    __t4_D11=;    __t4_D12=;    __t4_D13=;    __t4_D14=;
    __t4_D15=;    __t4_D16=;    __t4_D17=;    __t4_D18=;    __t4_D19=;
    __t4_D20=;    __t4_D21=;    __t4_D22=;    __t4_D23=;    __t4_D24=;
    __t4_D25=;    __t4_D26=;    __t4_D27=;    __t4_D28=;    __t4_D29=;
    __t4_D30=;    __t4_D31=;    __t4_D32=;    __t4_D33=;    __t4_D34=;
    __t4_D35=;    __t4_D35=;    __t4_D36=;    __t4_D38=;    __t4_D39=;
    __t4_D40=;    __t4_D41=;    __t4_D42=;    __t4_D43=;    __t4_D44=;
    __t4_D45=;    __t4_D46=;    __t4_D47=;    __t4_D48=;    __t4_D49=;
    __t4_D50=;    __t4_D51=;    __t4_D52=;    __t4_D53=;    __t4_D54=;
    __t4_D55=;    __t4_D56=;    __t4_D57=;    __t4_D58=;    __t4_D59=;
    __t4_D60=;    __t4_D61=;    __t4_D62=;    __t4_D63=;    __t4_D64=;
    __t4_D65=;    __t4_D66=;    __t4_D67=;    __t4_D68=;    __t4_D69=;
    __t4_D70=;    __t4_D71=;    __t4_D72=;    __t4_D73=;    __t4_D74=;
    __t4_D75=;    __t4_D76=;    __t4_D77=;    __t4_D78=;    __t4_D79=;
    __t4_D80=;    __t4_D81=;    __t4_D82=;    __t4_D83=;    __t4_D84=;
    __t4_D85=;    __t4_D86=;    __t4_D87=;    __t4_D88=;    __t4_D89=;
    __t4_D90=;    __t4_D91=;    __t4_D92=;    __t4_D93=;    __t4_D94=;
    __t4_D95=;    __t4_D96=;    __t4_D97=;    __t4_D98=;    __t4_D99=;


    __t4_pwd=""
    __t4_newline_before=""
    __t4_newline_after=""
    __t4_tune=""
    __t4_force=""
  }

}


__tartify_print_PS1_globs(){

  # REPOSITORY NAME
     echo "${__K_}__t4_rep=${__NN_}$__t4_rep"   # repo name
    echo "${__K_}__t4_sepN=${__NN_}$__t4_sepN"   # dynamic separator for repo name

  # BRANCH
      #

      echo "${__K_}__t4_tU=${__NN_}$__t4_tU"   
      echo "${__K_}__t4_tuSr=${__NN_}$__t4_tuSr" 
      echo "${__K_}__t4_tRA=${__NN_}$__t4_tRA"  
      echo "${__K_}__t4_tRD=${__NN_}$__t4_tRD"  
      echo "${__K_}__t4_tRI=${__NN_}$__t4_tRI"  
      echo "${__K_}__t4_tRO=${__NN_}$__t4_tRO"  
      echo "${__K_}__t4_tRN=${__NN_}$__t4_tRN"  
      echo "${__K_}__t4_turS=${__NN_}$__t4_turS" 
      echo "${__K_}__t4_TU=${__NN_}$__t4_TU"   
      echo "${__K_}__t4_TuSr=${__NN_}$__t4_TuSr" 
      echo "${__K_}__t4_TRA=${__NN_}$__t4_TRA"  
      echo "${__K_}__t4_TRD=${__NN_}$__t4_TRD"  
      echo "${__K_}__t4_TRI=${__NN_}$__t4_TRI"  
      echo "${__K_}__t4_TRO=${__NN_}$__t4_TRO"  
      echo "${__K_}__t4_TRN=${__NN_}$__t4_TRN"  
      echo "${__K_}__t4_TurS=${__NN_}$__t4_TurS" 

     echo "${__K_}__t4_sepB=${__NN_}$__t4_sepB"  
     echo "${__K_}__t4_merg=${__NN_}$__t4_merg"  
     echo "${__K_}__t4_bare=${__NN_}$__t4_bare"  


  #REMOTE
    echo "${__K_}__t4_sepR=${__NN_}$__t4_sepR";
    echo "${__K_}__t4_rOt=${__NN_}$__t4_rOt";
    echo "${__K_}__t4_rOn=${__NN_}$__t4_rOn";
    echo "${__K_}__t4_rO1p=${__NN_}$__t4_rO1p";
    echo "${__K_}__t4_rOac=${__NN_}$__t4_rOac";
    echo "${__K_}__t4_rOsep=${__NN_}$__t4_rOsep";
    echo "${__K_}__t4_rObc=${__NN_}$__t4_rObc";
    echo "${__K_}__t4_rO2p=${__NN_}$__t4_rO2p";

    echo "${__K_}__t4_rUt=${__NN_}$__t4_rUt";
    echo "${__K_}__t4_rUn=${__NN_}$__t4_rUn";
    echo "${__K_}__t4_rU1p=${__NN_}$__t4_rU1p";
    echo "${__K_}__t4_rUac=${__NN_}$__t4_rUac";
    echo "${__K_}__t4_rUsep=${__NN_}$__t4_rUsep";
    echo "${__K_}__t4_rUbc=${__NN_}$__t4_rUbc";
    echo "${__K_}__t4_rU2p=${__NN_}$__t4_rU2p";

    echo "${__K_}__t4_r1t=${__NN_}$__t4_r1t";
    echo "${__K_}__t4_r1n=${__NN_}$__t4_r1n";
    echo "${__K_}__t4_r11p=${__NN_}$__t4_r11p";
    echo "${__K_}__t4_r1ac=${__NN_}$__t4_r1ac";
    echo "${__K_}__t4_r1sep=${__NN_}$__t4_r1sep";
    echo "${__K_}__t4_r1bc=${__NN_}$__t4_r1bc";
    echo "${__K_}__t4_r12p=${__NN_}$__t4_r12p";

    echo "${__K_}__t4_r2t=${__NN_}$__t4_r2t";
    echo "${__K_}__t4_r2n=${__NN_}$__t4_r2n";
    echo "${__K_}__t4_r21p=${__NN_}$__t4_r21p";
    echo "${__K_}__t4_r2ac=${__NN_}$__t4_r2ac";
    echo "${__K_}__t4_r2sep=${__NN_}$__t4_r2sep";
    echo "${__K_}__t4_r2bc=${__NN_}$__t4_r2bc";
    echo "${__K_}__t4_r22p=${__NN_}$__t4_r22p";

    echo "${__K_}__t4_r3t=${__NN_}$__t4_r3t";
    echo "${__K_}__t4_r3n=${__NN_}$__t4_r3n";
    echo "${__K_}__t4_r31p=${__NN_}$__t4_r31p";
    echo "${__K_}__t4_r3ac=${__NN_}$__t4_r3ac";
    echo "${__K_}__t4_r3sep=${__NN_}$__t4_r3sep";
    echo "${__K_}__t4_r3bc=${__NN_}$__t4_r3bc";
    echo "${__K_}__t4_r32p=${__NN_}$__t4_r32p";


  #STASH
     echo "${__K_}__t4_st=${__NN_}$__t4_st"   
     echo "${__K_}__t4_ST=${__NN_}$__t4_ST"   
   echo "${__K_}__t4_sepS=${__NN_}$__t4_sepS"   

  #LAST COMMIT
    echo "${__K_}__t4_sepL=${__NN_}$__t4_sepL"   
    echo "${__K_}__t4_lccan=${__NN_}$__t4_lccan"  
    echo "${__K_}__t4_lccal=${__NN_}$__t4_lccal"  
    echo "${__K_}__t4_lccah=${__NN_}$__t4_lccah"  
    echo "${__K_}__t4_lscan=${__NN_}$__t4_lscan"  
    echo "${__K_}__t4_lscal=${__NN_}$__t4_lscal"  
    echo "${__K_}__t4_lscah=${__NN_}$__t4_lscah"  
    echo "${__K_}__t4_lnhan=${__NN_}$__t4_lnhan"  
    echo "${__K_}__t4_lnhal=${__NN_}$__t4_lnhal"  
    echo "${__K_}__t4_lnhah=${__NN_}$__t4_lnhah"  


  #_t4_D*

    echo "__t4_D0=$__t4_D0";     echo "__t4_D1=$__t4_D1";     echo "__t4_D2=$__t4_D2";     echo "__t4_D3=$__t4_D3";     echo "__t4_D4=$__t4_D4";
    echo "__t4_D5=$__t4_D5";     echo "__t4_D6=$__t4_D6";     echo "__t4_D7=$__t4_D7";     echo "__t4_D8=$__t4_D8";     echo "__t4_D9=$__t4_D9";
    echo "__t4_D10=$__t4_D10";    echo "__t4_D11=$__t4_D11";    echo "__t4_D12=$__t4_D12";    echo "__t4_D13=$__t4_D13";    echo "__t4_D14=$__t4_D14";
    echo "__t4_D15=$__t4_D15";    echo "__t4_D16=$__t4_D16";    echo "__t4_D17=$__t4_D17";    echo "__t4_D18=$__t4_D18";    echo "__t4_D19=$__t4_D19";
    echo "__t4_D20=$__t4_D20";    echo "__t4_D21=$__t4_D21";    echo "__t4_D22=$__t4_D22";    echo "__t4_D23=$__t4_D23";    echo "__t4_D24=$__t4_D24";
    echo "__t4_D25=$__t4_D25";    echo "__t4_D26=$__t4_D26";    echo "__t4_D27=$__t4_D27";    echo "__t4_D28=$__t4_D28";    echo "__t4_D29=$__t4_D29";
    echo "__t4_D30=$__t4_D30";    echo "__t4_D31=$__t4_D31";    echo "__t4_D32=$__t4_D32";    echo "__t4_D33=$__t4_D33";    echo "__t4_D34=$__t4_D34";
    echo "__t4_D35=$__t4_D35";    echo "__t4_D35=$__t4_D35";    echo "__t4_D36=$__t4_D36";    echo "__t4_D38=$__t4_D38";    echo "__t4_D39=$__t4_D39";
    echo "__t4_D40=$__t4_D40";    echo "__t4_D41=$__t4_D41";    echo "__t4_D42=$__t4_D42";    echo "__t4_D43=$__t4_D43";    echo "__t4_D44=$__t4_D44";
    echo "__t4_D45=$__t4_D45";    echo "__t4_D46=$__t4_D46";    echo "__t4_D47=$__t4_D47";    echo "__t4_D48=$__t4_D48";    echo "__t4_D49=$__t4_D49";
    echo "__t4_D50=$__t4_D50";    echo "__t4_D51=$__t4_D51";    echo "__t4_D52=$__t4_D52";    echo "__t4_D53=$__t4_D53";    echo "__t4_D54=$__t4_D54";
    echo "__t4_D55=$__t4_D55";    echo "__t4_D56=$__t4_D56";    echo "__t4_D57=$__t4_D57";    echo "__t4_D58=$__t4_D58";    echo "__t4_D59=$__t4_D59";
    echo "__t4_D60=$__t4_D60";    echo "__t4_D61=$__t4_D61";    echo "__t4_D62=$__t4_D62";    echo "__t4_D63=$__t4_D63";    echo "__t4_D64=$__t4_D64";
    echo "__t4_D65=$__t4_D65";    echo "__t4_D66=$__t4_D66";    echo "__t4_D67=$__t4_D67";    echo "__t4_D68=$__t4_D68";    echo "__t4_D69=$__t4_D69";
    echo "__t4_D70=$__t4_D70";    echo "__t4_D71=$__t4_D71";    echo "__t4_D72=$__t4_D72";    echo "__t4_D73=$__t4_D73";    echo "__t4_D74=$__t4_D74";
    echo "__t4_D75=$__t4_D75";    echo "__t4_D76=$__t4_D76";    echo "__t4_D77=$__t4_D77";    echo "__t4_D78=$__t4_D78";    echo "__t4_D79=$__t4_D79";
    echo "__t4_D80=$__t4_D80";    echo "__t4_D81=$__t4_D81";    echo "__t4_D82=$__t4_D82";    echo "__t4_D83=$__t4_D83";    echo "__t4_D84=$__t4_D84";
    echo "__t4_D85=$__t4_D85";    echo "__t4_D86=$__t4_D86";    echo "__t4_D87=$__t4_D87";    echo "__t4_D88=$__t4_D88";    echo "__t4_D89=$__t4_D89";
    echo "__t4_D90=$__t4_D90";    echo "__t4_D91=$__t4_D91";    echo "__t4_D92=$__t4_D92";    echo "__t4_D93=$__t4_D93";    echo "__t4_D94=$__t4_D94";
    echo "__t4_D95=$__t4_D95";    echo "__t4_D96=$__t4_D96";    echo "__t4_D97=$__t4_D97";    echo "__t4_D98=$__t4_D98";    echo "__t4_D99=$__t4_D99";


    echo "${__K_}__t4_newline_before=${__NN_}$__t4_newline_before"
    echo "${__K_}__t4_newline_after=${__NN_}$__t4_newline_after"
    echo "${__K_}__t4_tune=${__NN_}$__t4_tune"
    echo "${__K_}__t4_force=${__NN_}$__t4_force"

}


__tartify_init_globs(){

  # Internal (RESERVED)

  export TARTIFY_OPTIONS_ELEMENTS='aAbBlLmMnNorRsS'
  export TARTIFY_OPTIONS_MODES='0123456789pqv'
  export TARTIFY_OPTIONS_MODIFIERS='cdfItwW'
  export TARTIFY_OPTIONS_HELP='eh'
  #export TARTIFY_OPTIONS="${TARTIFY_OPTIONS_ELEMENTS}${TARTIFY_OPTIONS_MODES}${TARTIFY_OPTIONS_MODIFIERS}${TARTIFY_OPTIONS_HELP}"
  export TARTIFY_OPTIONS="0123456789aAbBcdefhIlLmMnNopqrRsStwW"

  # External TARTIFY PARAMETERS : adapt to your needs

  #-------------------------------------------------------
  # GLOBAL

  export TARTIFY_FORCE=""                                 # A string containing tartify command-line params. If non empty, will
                                                          # overwrite any arguments the tartify command receives

  export TARTIFY_STRING_MISC_SEPARATOR=" "                # Default separator to be used with 'separator-less' tartify options

  #-------------------------------------------------------
  # TIME
  # //COMMIT-WISE
  export TARTIFY_SETTING_TIME_BUGME=TRUE                  # Non empty : will color and style the 'time since last commit' string
  #TODO: MEDIUM
                                                          # which of the 4 elements (year, days, hour, minues) to display
  export TARTIFY_SETTING_TIME_DISPLAY=LONG                # LONG (min, hours, days) MEDIUM (2 elements) SHORT (1 element) CHAR (cf. next var)

  [ "true" = $supports8 ] && {
  export TARTIFY_STRING_TIME_CHARDISPLAY="⟳ "                 # String to display in case prec. var == CHAR
  } || {
  export TARTIFY_STRING_TIME_CHARDISPLAY="◉ "                 # String to display in case prec. var == CHAR
  }

                                                          # Uncommited changes (staged, unstaged)
  export TARTIFY_SETTING_TIME_COULDCOMMIT=14400           #     *     nb seconds after which you COULD  commit (default is 4 hours)
  export TARTIFY_SETTING_TIME_SHOULDCOMMIT=86400          #     * Max nb seconds after which you SHOULD commit (default is 1 day)

                                                          # styles applied to the 'time elapsed since last commit'
                                                          # string, in case of uncommited changes
  export TARTIFY_STYLE_TIME_COULDCOMMIT=${__UN_}          #                                  UNDERLINED
  export TARTIFY_STYLE_TIME_SHOULDCOMMIT=${__EM_}${__UN_} #                           BOLD UNDERLINED



  # //ACTIVITY-WISE
  export TARTIFY_SETTING_TIME_LOWACTIVITY=604800          #     *     nb seconds after which ACTIVITY is considered low (default is  7 days)
  export TARTIFY_SETTING_TIME_MEDIUMACTIVITY=86400        #     * Max nb seconds after which ACTIVITY is considered medium (default is  1 day)
                                                          # colors applied to the 'time elapsed since last commit'
                                                          # string in case of no uncommited changes
  export TARTIFY_COLOR_TIME_ACTIVITY_HIGH=${__G_}         #                                  GREEN
  export TARTIFY_COLOR_TIME_ACTIVITY_LOW=${__Y_}          #                                  YELLOW
  export TARTIFY_COLOR_TIME_ACTIVITY_NONE=${__R_}         #                                  RED

  #-------------------------------------------------------
  #BRANCH
  export TARTIFY_STRING_BRANCH_DOTGIT="GIT_DIR!"                 # "branch name" replacement string for .git directory
  export TARTIFY_STRING_BRANCH_BARE="BARE:"                      # "branch name" replacement string for bare .git directory
  export TARTIFY_COLOR_BRANCH_BARE=$__EMW_                       # "branch name" replacement string for bare .git directory

  #Branch style : Untracked files
  export TARTIFY_STYLE_BRANCH_UNTRACKED=${__UN_}                 # Untracked Files                  UNDERLINED
  export TARTIFY_SETTING_BRANCH_UNTRAKEDLOCAL=""          # If non-empty, the untracked markers show untracked files limited only
                                                          # to 'local directory', not the whole repository

  # Branch COLOR : first 2 chars
  export TARTIFY_COLOR_BRANCH_UNSTAGED=${__EMR_}          # unstaged changes (first char)    BOLD RED
  export TARTIFY_COLOR_BRANCH_STAGED=${__EMM_}            # staged changes   (2nd char)      BOLD MAGENTA
  # Branch COLOR : remaining chars
  export TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE=${__K_}  # tracked remot diverg from HEAD   BOLD DARK GREY
  export TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND=${__R_}     # tracked remote ahead of HEAD     RED
  export TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD=${__Y_}      # tracked remote behind HEAD       YELLOW
  export TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE=${__G_}   # tracked remote == HEAD           GREEN
  export TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK=${__B_}    # no remote tracking branch        BLUE
                                                          # NB: this is also the color used when
                                                          # tartify does not display 'upstream' info in branch

  export TARTIFY_COLOR_BRANCH_NOCOMMITYET=${__W_}         # empty repo, no commit yet        WHITE
  export TARTIFY_COLOR_BRANCH_GITDIR=${__C_}              # inside .git dir                  CYAN

  #Branch color : additional info
  export TARTIFY_COLOR_BRANCH_MERGEINFOS=${__RV_}${__EMR_} # color for the merge/rebase/cherry-pick/bisect status of current branch (if any)
                                                          #                                  BOLD RED

  # Tartify shows U (Unstaged state), S (Staged state) and P (uPstream state:
  # ahead, behind, diverged, uptodate) directly in the branch name, with 3
  # different colors. The order of these informations can be tuned for
  # better readability
  export TARTIFY_SETTING_BRANCH_STAGED_INFO=              # empty     -> (unstaged)UPSTREAM[staged]
                                                          # non-empty -> (unstaged)[staged]UPSTREAM
  export TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH=2       # How many letters of resulting branchname are to be colored with
                                                          # the "unstaged" and "staged" marker colors
                                                          # NB: this number cannot exceed int(length /2), see below
  # Example:
  #     () for      unstaged,      [] for      staged,     rest: upstream info
  #
  #     $TARTIFY_SETTING_BRANCH_STAGED_INFO empty
  #     $TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH =
  #     0 : master    1 : (m)aste[r]    2 : (ma)st[er]    3 : (mas)[ter]    4 : (mas)[ter]    ,...
  #     0 : feature   1 : (f)eatur[e]   2 : (fe)atu[re]   3 : (fea)t[ure]   4 : (fea)t[ure]   ,...
  #
  #     $TARTIFY_SETTING_BRANCH_STAGED_INFO non-empty
  #     $TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH =
  #     0 : master    1 : (m)[a]ster    2 : (ma)[st]er    3 : (mas)[ter]    4 : (mas)[ter]    ,...


  #-------------------------------------------------------
  # ANCESTOR
  export TARTIFY_COLOR_ANCESTOR_NAME=${__EMM_}            # parent repository's "name"                      MAGENTA
  [ "true" = $supports8 ] && {
  export TARTIFY_STRING_ANCESTOR_MARKER="↪"               # if non empty, will replace the name of the parent repository
                                                          # in the 'ancestor' field in case of a submodule
  } || {
  export TARTIFY_STRING_ANCESTOR_MARKER=">"
  }
  export TARTIFY_STRING_ANCESTOR_NOSUB="X"                # string output before ancestor repo's name in case sub-repo is
                                                          # a valid submodule

  #-------------------------------------------------------
  # REPOSITORY
  export TARTIFY_COLOR_REPO_NAMEALONE=${__C_}             # repository's "name"                            CYAN
  export TARTIFY_COLOR_REPO_NAMEBASE=${__EMC_}            # 'm/M' option : repository's "base-name"        BOLD CYAN
  export TARTIFY_COLOR_REPO_LOCALPATH=${__C_}             # 'm/M' option : local path in repo repository   CYAN

  #-------------------------------------------------------
  # REMOTES
                                                          # leave empty for PAREN, whitespace for NOPAREN
                                                          # (this because it's a bad idea to store a litteral
                                                          #  paren in an environment variable)
  export TARTIFY_STRING_REMOTE_1STPAREN=""                # opening paren for  remote ahead/behind count
  export TARTIFY_STRING_REMOTE_2NDPAREN=""                # opening paren for remote ahead/behind count

  export TARTIFY_STRING_REMOTE_SEP=" "                    # (optionnal) separator between remotes
  export TARTIFY_STRING_REMOTE_COUNTSEP="/"               # separator for ahead/behind count
  export TARTIFY_STRING_REMOTE_ORIGIN="O"                 # marker for remote repo called 'origin'
  export TARTIFY_STRING_REMOTE_UPSTREAM="U"               # marker for remote repo called 'upstream'
  [ "true" = $supports8 ] && {
  export TARTIFY_STRING_REMOTE_OTHER=" ⇧ "                 # generic marker for remote repo
  export TARTIFY_STRING_REMOTE_TRACKING="➝ "              # marker for tracked branch
  } || {
  export TARTIFY_STRING_REMOTE_OTHER="X "                 # generic marker for remote repo
  export TARTIFY_STRING_REMOTE_TRACKING=">"              # marker for tracked branch
  }

  export TARTIFY_COLOR_REMOTE_NAME_ORIGIN=${__G_}         # color for origin remote marker   GREEN
  export TARTIFY_COLOR_REMOTE_NAME_UPSTREAM=${__M_}       # color for upstream remote marker MAGENTA
  export TARTIFY_COLOR_REMOTE_NAME_OTHER=${__Y_}          # color for other remote marker    YELLOW


  export TARTIFY_COLOR_REMOTE_COUNT_AHEAD=${__G_}         # nb commits ahead of remote       GREEN
  export TARTIFY_COLOR_REMOTE_COUNT_BEHIND=${__R_}        # nb commits behind of remote      RED


  #-------------------------------------------------------
  # STASH
  export TARTIFY_SETTING_STASH_COUNT=                    # non empty: print 1 $TARTIFY_STRING_STASH per existing stash
                                                          # (WARN: this is slow process, add ~50ms computing time)
  [ "true" = $supports8 ] && {
  #export TARTIFY_STRING_STASH="☆ "                        # marker for stash
  export TARTIFY_STRING_STASH="•"                         # marker for stash
  } || {
  export TARTIFY_STRING_STASH="*"                         # marker for stash
  }
  export TARTIFY_COLOR_STASH_NOCOUNT=${__Y_}              # color when not counting          YELLOW
  export TARTIFY_COLOR_STASH_COUNT=${__EMY_}              # color in "count mode"            BOLD YELLOW

  #-------------------------------------------------------
  # UNPARSED CHARS
  export TARTIFY_COLOR_MISC_DELIMITER=${__K_}             # color for (unparsed) delimiters  DIM GREY


  #-------------------------------------------------------
  # MENU

  export TARTIFY_COLOR_MENU_BORDER=$__B_

  [ "true" = $supports8 ] && {
    export TARTIFY_STRING_MENU_TOPLEFT="┌"
    export TARTIFY_STRING_MENU_TOP="─"
    export TARTIFY_STRING_MENU_TOPRIGHT="┐"
    export TARTIFY_STRING_MENU_LEFT="│"
    export TARTIFY_STRING_MENU_RIGHT="│"
    export TARTIFY_STRING_MENU_BOTTOMLEFT="└"
    export TARTIFY_STRING_MENU_BOTTOM="─"
    export TARTIFY_STRING_MENU_BOTTOMRIGHT="┘"
  } || {
    export TARTIFY_STRING_MENU_TOPLEFT=" "
    export TARTIFY_STRING_MENU_TOP="_"
    export TARTIFY_STRING_MENU_TOPRIGHT=" "
    export TARTIFY_STRING_MENU_LEFT=" "
    export TARTIFY_STRING_MENU_RIGHT=" "
    export TARTIFY_STRING_MENU_BOTTOMLEFT=" "
    export TARTIFY_STRING_MENU_BOTTOM="_"
    export TARTIFY_STRING_MENU_BOTTOMRIGHT=" "
  }

  #-------------------------------------------------------
  # SMART PWD

  export TARTIFY_SETTING_PWD_MAXLEN=25         # ('d' option) How many characters of the $PWD should be kept
  export TARTIFY_SETTING_REPO_NAMEMAXLEN=15     # ('m/M' option) How many characters of the $PWD should be kept
  export TARTIFY_STRING_PWD_TRUNCSYMBOL='..'   # ('d' option) Indicate that there has been dir truncation
  export TARTIFY_COLOR_PWD=$__C_               # ('d' option) Color for PWD


}


__tartitune_init_globs(){

  #-------------------------------------------------------
  # GLOBAL
  export TARTITUNE_SETTING_FORCE="false"                  # "true" : enter a tartitune session
}


#------------------------------------------------------------------------------
#
#             ORIGINAL __git_ps1 FUNCTIONS (tuned to tartify)
#
#------------------------------------------------------------------------------
#
# following functions are copy/paste of the original functions from
# bash-completion.sh, slightly tuned for tartify.
#
#    __tartify__git_ps1_find_upstream   *CLONES*    first part of __git_ps1_show_upstream
#    __tartify_git_ps1_process_remote   *CLONES*    second part of __git_ps1_show_upstream
#    __tartify_git_ps1                  *CLONES*    __git_ps1
#
# This, to ease keeping compatibility with original __git_ps1(), and to
# ease updates (at the cost of spaghettying tartify's code even more
# with dynamic variable scope *shit*)
#
# Modifications :
#
# * all local declarations moved to tartify(), as it's the root of our
#   local dynamic scope
#
# Note: keep chunks of code in original order to ease diffing


__tartify_git_ps1_find_upstream () {
  # fills the tartify() local variables :
  #    $upstream
  #    $verbose
  #    $legacy


  # hack to restrain the following modification to this global variable
  # to local dynamic scope, and set it to "auto" for all modes
  # but __git_ps1 compatibility mode
  local GIT_PS1_SHOWUPSTREAM=$GIT_PS1_SHOWUPSTREAM
  [ "OLDSCHOOL" = "$branchstyle" ] || GIT_PS1_SHOWUPSTREAM="auto"
  #[ "OLDSCHOOL" = "$branchstyle" ] || GIT_PS1_SHOWUPSTREAM="auto verbose"


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  local key value
  local svn_remote=() svn_url_pattern count n
  #local upstream=git legacy="" verbose=""

  # get some config options from git-config
  while read key value; do
    case "$key" in
    bash.showupstream)
      GIT_PS1_SHOWUPSTREAM="$value"
      if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]] && [ "OLDSCHOOL" = "$branchstyle" ]; then
        p=""
        return
      fi
      ;;
    svn-remote.*.url)
      svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value"
      svn_url_pattern+="\\|$value"
      upstream=svn+git # default upstream is SVN if available, else git
      ;;
    esac
  done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')

  # parse configuration values
  for option in ${GIT_PS1_SHOWUPSTREAM}; do
    case "$option" in
    git|svn) upstream="$option" ;;
    verbose) verbose=1 ;;
    legacy)  legacy=1  ;;
    esac
  done

  # Find our upstream
  case "$upstream" in
  git)    upstream="@{upstream}" ;;
  svn*)
    # get the upstream from the "git-svn-id: ..." in a commit message
    # (git-svn uses essentially the same procedure internally)
    local svn_upstream=($(git log --first-parent -1 \
          --grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
    if [[ 0 -ne ${#svn_upstream[@]} ]]; then
      svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}
      svn_upstream=${svn_upstream%@*}
      local n_stop="${#svn_remote[@]}"
      for ((n=1; n <= n_stop; ++n)); do
        svn_upstream=${svn_upstream#${svn_remote[$n]}}
      done

      if [[ -z "$svn_upstream" ]]; then
        # default branch name for checkouts with no layout:
        upstream=${GIT_SVN_ID:-git-svn}
      else
        upstream=${svn_upstream#/}
      fi
    elif [[ "svn+git" = "$upstream" ]]; then
      upstream="@{upstream}"
    fi
    ;;
  esac
  # ----- END   __git_ps1_show_upstream chunk -----


}


__tartify_git_ps1_process_remote () {
  # by default, processes the value of $upstream (tartify()'s scope)
  # as previously set by __tartify_git_ps1_find_upstream()
  # or something else if an argument is given
  [ ${#1} -gt 0 ] && upstream=$1


  # ----- BEGIN __git_ps1_show_upstream chunk -----
  # Find how many commits we are ahead/behind our upstream
  if [ ${#legacy} == 0 ]; then
  #if [[ -z "$legacy" ]]; then
    count="$(git rev-list --count --left-right \
        "$upstream"...HEAD 2>/dev/null)"
  else
    # produce equivalent output to --count for older versions of git
    local commits
    if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
    then
      local commit behind=0 ahead=0
      for commit in $commits
      do
        case "$commit" in
        "<"*) let ++behind
          ;;
        *)    let ++ahead
          ;;
        esac
      done
      count="$behind  $ahead"
    else
      count=""
    fi
  fi

  # calculate the result
  if [[ -z "$verbose" ]]; then
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p="=" ;;
    "0	"*) # ahead of upstream
      p=">" ;;
    *"	0") # behind upstream
      p="<" ;;
    *)      # diverged from upstream
      p="<>" ;;
    esac
  else
    case "$count" in
    "") # no upstream
      p="" ;;
    "0	0") # equal to upstream
      p=" u=" ;;
    "0	"*) # ahead of upstream
      p=" u+${count#0	}" ;;
    *"	0") # behind upstream
      p=" u-${count%	0}" ;;
    *)      # diverged from upstream
      p=" u+${count#*	}-${count%	*}" ;;
    esac
  fi

  # ----- END   __git_ps1_show_upstream chunk -----
}


__tartify_git_ps1(){
  #local g="$(__gitdir)"
  if [ -n "$g" ]; then
    #local r=""
    #local b=""
    if [ -f "$g/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    elif [ -d "$g/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$g/rebase-merge/head-name")"
    else
      if [ -d "$g/rebase-apply" ]; then
        if [ -f "$g/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$g/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$g/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
        r="|CHERRY-PICKING"
      elif [ -f "$g/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --tags --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    #local w=""
    #local i=""
    #local s=""
    #local u=""
    #local c=""
    #local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        c=$TARTIFY_STRING_BRANCH_BARE
        idaongbe="B"
      else
        b="GIT_DIR!"
        idaongbe="G"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] || [ "OLDSCHOOL" != "$branchstyle" ]; then
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
          else
            i="#"
            idaongbe="E"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] || [ "OLDSCHOOL" != "$branchstyle" ]; then
              git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] || [ "OLDSCHOOL" != "$branchstyle" ]; then
        #__GIT_PS1 source modif :
        if [ -z "$TARTIFY_SETTING_BRANCH_UNTRAKEDLOCAL" ]; then
            if [ -n "$(cd "$repopath"; git ls-files --others --exclude-standard)" ]; then
                u="%"
            fi
        else
            if [ -n "$( git ls-files --others --exclude-standard)" ]; then
                u="%"
            fi
        fi
        #//__GIT_PS1 source modif :
      fi

      if [ "true" = "$processupstream" ] && [ -n $upstream ]; then
        #no arg : processes upstream
        __tartify_git_ps1_process_remote
      fi
    fi

    f="$w$i$s$u"
    #local f="$w$i$s$u"
    #printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p"
  fi

}


#------------------------------------------------------------------------------
#
#             HELPER FUNCTIONS
#
#------------------------------------------------------------------------------


__tartify_diff_count() {
#count the nb of commits between two branches of two repositorie
#   ex: __tartify_diff_count HEAD origin/master
#   ex: __tartify_diff_count upstream/dev HEAD
    echo "$(git rev-list $1..$2 2>/dev/null | awk 'END {print NR}')"
}

__tartify_usage() {

  #PAGER SHIT

  local __mypager
  # NO PAGER SET
  if [ -z "$PAGER" ]; then 
    if most --version >/dev/null 2>&1 ; then
      __mypager="most"
    elif less --version >/dev/null 2>&1; then
      __mypager="less"
    else
      __mypager="more"
    fi
  else
    __mypager="$PAGER"
  fi

  # Make LESS/MORE eat-up our ESCAPES
  local __myoldLESS="$LESS"
  local __myoldMORE="$MORE"
  if [ "$__mypager" = "less" ] || [ "$__mypager" = "more" ]; then
    LESS="-R"
    MORE="-R"
  fi

  #Display the HELP page
  eval $1 | $__mypager
  #__tartify_Helpmsg | $__mypager

  #Restore SHELL settings

  LESS="$__myoldLESS"
  MORE="$__myoldMORE"
}


__tartify_Helpmsg(){

  local __EM_=$( tput bold   || : 2>/dev/null                 ) #   BEGIN DOUBLE INTENSITY (bold) mode
  local __SO_=$( tput smso   || : 2>/dev/null                 ) #   BEGIN STANDOUT      (reverse) mode
  local __SOQ_=$( tput rmso  || : 2>/dev/null                 ) #   END   STANDOUT      (reverse) mode
  local __UN_=$( tput smul   || : 2>/dev/null                 ) #   BEGIN UNDESCORE  (underlined) mode
  local __UNQ_=$( tput rmul  || : 2>/dev/null                 ) #   END   UNDESCORE  (underlined) mode

# Display the help message
  cat <<HELPTEXT

${__EMR_}NAME
     tartify${__NN_} -- One-Liner condensed GIT infos (for your prompt, screen
                statusline, ...)

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}tartify${__NN_} [${__EMG_}option string${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     The ${__EMG_}option string${__NN_} is a CASE-SENSITIVE sequence of characters.

      * The following characters are reserved tartify commands :
         ${__Y_}${TARTIFY_OPTIONS}${__NN_}
         (and maybe more alphhanumeric characters in the future)

      * any other character will be printed "as is", including spaces. You can use
      those to format the output of the tarttify command (as delimiters,...)
              \`tartify [r]b - l\` will output "[repository]branch - time"

      * if you need multiple spaces, escape them "\ " :
              \`tartify [r]b -\ \ l\` will output "[repository]branch -  time"

      * following characters need to be escaped  ${__Y_}()<>;*"'\`#&|~${__NN_}


      ${__EMG_}Elements${__NN_}

      ${__K_}┌${__Y_}n${__NN_}       repository ${__EMY_}n${__NN_}ame          ${__Y_}N${__NN_}   same without colors
      ${__K_}└${__Y_}m${__NN_}       rep na${__EMY_}m${__NN_}e + local path    ${__Y_}M${__NN_}   same without colors
       ${__Y_}a${__NN_}       ${__EMY_}a${__NN_}ncestor (indicator      ${__Y_}A${__NN_}   same without colors
               if we're inside submodule)
      ${__K_}┌${__Y_}b${__NN_}       ${__EMY_}b${__NN_}ranch name              ${__Y_}B${__NN_}          \` \`
      ${__K_}└${__Y_}o${__NN_}       branch name ${__EMY_}o${__NN_}ldschool (__git_ps1)
       ${__Y_}r${__NN_}       ${__EMY_}r${__NN_}emotes (all)            ${__Y_}R${__NN_}          \` \`
       ${__Y_}s${__NN_}       ${__EMY_}s${__NN_}tash info               ${__Y_}S${__NN_}          \` \`
       ${__Y_}l${__NN_}       ${__EMY_}l${__NN_}ast commit info         ${__Y_}L${__NN_}          \` \`

      ${__EMG_}Modes${__NN_}

              default    default mode is implicit
      ${__Y_}q${__NN_}       ${__EMY_}q${__NN_}uiet      only update PS1 variables, no output to STDOUT
      ${__Y_}p${__NN_}       ${__EMY_}p${__NN_}s1 mode   generate string with escaped (\[...\]) non-printing
                         characters and ${__EMR_}tartify${__NN_}'s own PS1 variables
      ${__Y_}v${__NN_}       ${__EMY_}v${__NN_}im mode   result formated for the Vim tartify plugin
                         (color info appended to result)

      ${__Y_}number${__NN_}  menu mode  display result as menu
              ┌───────────────────┐
              │${__EMY_}1/4/7 ${__NN_} ${__EMY_}2/5/8${__NN_}  ${__EMY_}3/6/9${__NN_}│
              │${__EMY_}    ${__NN_}      ${__EMY_} ${__NN_}       ${__EMY_} ${__NN_}│
              │${__EMY_}    ${__NN_}      ${__EMY_} ${__NN_}       ${__EMY_}0${__NN_}│
              └───────────────────┘
              1line prompt ${__EMY_}1${__NN_} top left  ${__EMY_}2${__NN_} top middle  ${__EMY_}3${__NN_} top right
              2line prompt ${__EMY_}4${__NN_} top left  ${__EMY_}5${__NN_} top middle  ${__EMY_}6${__NN_} top right
              3line prompt ${__EMY_}7${__NN_} top left  ${__EMY_}8${__NN_} top middle  ${__EMY_}9${__NN_} top right
              ${__EMY_}0${__NN_} bottom right (one liner)

      Mode's order of precedence ${__EMY_}p${__NN_}s1 -> ${__EMY_}q${__NN_}uiet -> ${__EMY_}m${__NN_}enu -> ${__EMY_}v${__NN_}im -> default

      ${__EMG_}Modifiers${__NN_}

      ${__Y_}d${__NN_}       pw${__EMY_}d${__NN_}          issue \$PWD if not in git repo
      ${__Y_}c${__NN_}       no${__EMY_}c${__NN_}olor      strip all colors
      ${__Y_}t${__NN_}       no ups${__EMY_}t${__NN_}ream  in branch (only staged/unstaged)
      ${__Y_}w${__NN_}       ne${__EMY_}w${__NN_}line      add newline at end of result
                           ignored in MENU mode
      ${__Y_}W${__NN_}       ne${__EMY_}W${__NN_}line      prepend newline to result
                           ignored in MENU mode
      ${__Y_}f${__NN_}       ${__EMY_}f${__NN_}orce        overwrite global TARTIFY_FORCE (once)
                           (see tartitune(), tartiforce() )
      ${__Y_}I${__NN_}       spl${__EMY_}I${__NN_}t        split output (positionnal)
                           -> left of  'I' : no output (=~ quiet mode)
                           -> right of 'I' : STDOUT
                           (useful when combining 'PS1' with 'menu mode')

      ${__EMG_}Help${__NN_} ${__EM_}all other arguments are ignored${__NN_}

      ${__Y_}h${__NN_}     ${__EMY_}h${__NN_}elp      display this help message
      ${__Y_}e${__NN_}     ${__EMY_}e${__NN_}nv help  list customizable environment variables

${__EMR_}DEFAULT${__NN_}
     tartify   : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrsl${__NN_}
     tartify w : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}nbrslw${__NN_}
     tartify o : is equivalent to ${__EM_}tartify${__EMQ_} ${__Y_}obsr${__NN_}

${__EMR_}SEE ALSO${__NN_}
     ${__Y_}tartitune${__NN_}  (easy tune  tartify's settings)
     ${__Y_}tartiforce${__NN_} (temp. force overwrite any options passed to tartify)

HELPTEXT
}

__tartitune_Helpmsg(){

  cat <<HELPMSG

${__EMR_}NAME
     tartitune${__NN_} -- Quick color changer for ${__EM_}tartify${__NN_}

${__EMR_}SYNOPSIS${__NN_}
     ${__EMR_}tartitune${__NN_} [${__EMR_}-SHORTNAME ...${__NN_}][${__EMR_}TARTIFY_[COLOR|STYLE]* ...${__NN_}][${__EMG_}compound${__NN_}]
     ${__EMR_}tartitune${__NN_} [${__EMG_}string_or_setting${__NN_}]
     ${__EMR_}tartitune${__NN_} [${__EMG_}action${__NN_}]

${__EMR_}DESCRIPTION${__NN_}
     1) The order of command line arguments doesn't matter. When used
     without arguments, ${__EMR_}tartitune${__NN_} pretty prints a list of ALL ${__EMR_}tartify${__NN_}
     environment variables with their current value (same as \`${__EMR_}tartify${__NN_} e\`)
     2) As soon as you modify a ${__EMR_}tartify${__NN_} environment variable with ${__EMR_}tartitune${__NN_},
     you enter a 'tartitune session' and all ${__EMR_}tartify${__NN_} results (STDOUT,
     PS1 or MENU) will be preceded by a ${__EMR_}*${__NN_} indicator, until you save your
     changes, export them or exit the session (see ${__EMG_}actions${__NN_} below)
     3) You can only use arguments from either ${__EMG_}compound${__NN_}, or ${__EMG_}string_or_setting${__NN_},
     or ${__EMG_}action${__NN_} at one given time

     The options have the following meaning:

     ${__EMR_}TARTIFY_[COLOR|STYLE]*${__NN_}
           any sequence of TARTIFY_COLOR_* or TARTIFY_STYLE_* environment 
           variables, by full name (eg: TARTIFY_COLOR_BRANCH_STAGED)
                -> case insensitive
                -> run ${__EMR_}tartitune${__NN_} without any argument to get a complete
                   list of ALL ${__EMR_}tartify${__NN_} environment variables with their
                   current value)
                -> use ${__EMG_}T+completion${__NN_} to loop through ${__EM_}full${__NN_} names

     ${__EMR_}-SHORTNAME${__NN_}
           any sequence of TARTIFY_COLOR or TARTIFY_STYLE environment
           variables, by short name (eg: -COLOR_STAGED), prefixed with 
           a ${__Y_}single-dash${__NN_}

            -> case insensitive
            -> use ${__EMG_}dash+completion${__NN_} to loop through ${__Y_}short${__NN_} names

           If no environement variable is specified, ${__EMR_}tartitune${__NN_}
           will print the compound color corresponding to ${__EMG_}compound${__NN_}
           to STDOUT

     ${__EMG_}compound${__NN_}  a list of any of the following words (case insensitive,
           use completion to loop through)

           ${__EM_}bold${__NN_}    ${__EM_}emphasized${__NN_} ${__UN_}underlined${__NN_} ${__RV_} inverse${__NN_}
                                         ${__RV_}/reverse${__NN_}

           ${__K_}black${__NN_}   ${__R_}red${__NN_}        ${__G_}green${__NN_}     ${__Y_}yellow${__NN_}
           ${__B_}blue${__NN_}    ${__M_}magenta${__NN_}    ${__C_}cyan${__NN_}      ${__W_}white${__NN_}

           ${__BGK_}BGblack${__NN_} ${__BGR_}BGred${__NN_}      ${__K_}${__BGG_}BGgreen${__NN_}   ${__K_}${__BGY_}BGyellow${__NN_}
           ${__K_}${__BGB_}BGblue${__NN_}  ${__K_}${__BGM_}BGmagenta${__NN_}  ${__K_}${__BGC_}BGcyan${__NN_}    ${__K_}${__BGW_}BGwhite${__NN_}

           ${__G_}test${__NN_}      Doesn't modify any environment variable, just simulates.

     ${__EMG_}string_or_setting${__NN_}  any ONE of the following words (case insensitive,
           use completion to loop through)

           ${__G_}bugme${__NN_}     switch TARTIFY_SETTING_TIME_BUGME setting on/off
           ${__G_}timelong${__NN_}  set    TARTIFY_SETTING_TIME_DISPLAY setting to LONG
           ${__G_}timeshort${__NN_} set    TARTIFY_SETTING_TIME_DISPLAY setting to SHORT
           ${__G_}timechar${__NN_}  set    TARTIFY_SETTING_TIME_DISPLAY setting to CHAR

     ${__EMG_}action${__NN_}  any ONE of the following words (case insensitive,
           use completion to loop through)

           ${__G_}export${__NN_}    Save the current ${__EMR_}tartify${__NN_} environment in ~/.tartitunebak
                     (WARN: will overwrite previous .tartitunebak silently).
                     Move ~/.tartitunebak to ~/.tartifyrc to make that the
                     default ${__EMR_}tartify${__NN_} environment.
           ${__G_}nuke${__NN_}      Replace ~/.tartifyrc with the current ${__EMR_}tartify${__NN_}
                     environment
           ${__G_}quit${__NN_}      Exit ${__EMR_}tartitune${__NN_} session (discard changes)
           ${__G_}last${__NN_}      Resume latest ${__EMR_}tartitune${__NN_} session

${__EMR_}LIMITATIONS${__NN_}

      * ${__EMR_}tartitune${__NN_} won't have visible effects on ${__EMR_}tartify${__NN_}'s ${__EMG_}compound${__NN_} colors 
        in your PS1 as the colors in PS1 are hardcoded at PS1 creation time.
        However, the indicator will be present. In which case, use ${__EMR_}tartify${__NN_}
        from the command line to see the coloring effects of ${__EMR_}tartitune${__NN_}
      * ${__EMG_}action${__NN_} and ${__EMG_}string_or_setting${__NN_} ${__EMR_}tartitune${__NN_} options will be reflected
        in PS1 realtime

${__EMR_}SEE ALSO${__NN_}
      tartify, tartiforce
${__EMR_}EXAMPLES${__NN_}

      ${__K_}\$ tartitune TARTIFY_COLOR_BRANCH_STAGED bold magenta${__NN_}
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED bold blue underline verbose${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMM_}was${__NN_}) (${__EMB_}${__UN_}now is${__NN_})
      ${__K_}\$ tartitune -COLOR_BRANCH_STAGED -COLOR_BRANCH_UPTODATE r i test${__NN_}
      TARTIFY_COLOR_BRANCH_STAGED (${__EMB_}${__UN_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE (${__EMG_}was${__NN_}) (${__EMR_}${__RV_}*TEST*${__NN_})
      ${__K_}\$ tartitune test bold cyan${__NN_}
      ${__EMC_}*TEST*${__NN_}
      ${__K_}\$ tartitune un yellow; echo \"colored string\"${__NN_}
      ${__Y_}${__UN_}colored string${__NN_}
      ${__K_}\$ MYENVVAR=\$(tartitune bo r); echo \$MYENVVAR\"colored string\"${__NN_}
      ${__EMR_}colored string${__NN_}

HELPMSG
}

__tartify_show_env() {
  #TODO: do that with less clutter, using something like :
  # echo ${!TARTIFY_*} | xargs  printf "%s\n" to list the args

  # pretty print TARTIFY environment
  echo;echo
  echo "   Tartify's ENVIRONMENT variables are currently"
  echo "   set to :"
  echo
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__W_$__BGK_             PREDEFINED COLORS                           $__NN_ "
  echo       "$__UN_$__W_$__BGK_          (for use in your dotfiles)                     $__NN_ "
  echo
  local simplecols=$(\
    env | grep '^__[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $simplecols

  local boldcols=$(\
    env | grep '^__EM[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $boldcols

  local bgcols=$(\
    env | grep '^__BG[A-Z]\{1\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,("\033[30m" $1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $bgcols

  local others=$(\
    env | grep -v '^__EM[A-Z]_\|__[A-Z]_\|__BG[A-Z]_' | grep '^__[A-Z]\{1,3\}_=' | sort -df |  awk -F"=" '{printf("%s%s%s ", "\033[0m",$2,($1 "\033[0m"))}'\
  )
  printf "$__K_$__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s  $__K_\$%-19s\n" $others


  #printf "%6s  %0s  %10s %s %10s %s %10s %s\n" $(
  #env | grep '^__[a-zA-Z]\{1,3\}_=' | sort -df\
  #    | awk -F"=" '{printf("%'0s'%'0s'%-'8s'%'0s'", "\033[0m    ",$2,($1 "\033[0m")," ")}'\
  #    )
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STRINGS                                $__NN_"
  echo
  env | grep "^TARTIFY_STRING_" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  SETTINGS                               $__NN_"
  echo
  env | grep "^TARTIFY_SETTING" | sort -df \
      | awk -F"=" '{printf("%'11s'%-'15s'%-'29s'%'0s'\n", "\033[0m    ",$2,$1," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  STYLES                                 $__NN_ "
  echo
  env | grep "^TARTIFY_STYLE" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo ""$__UN_"                                                         "$__NN_
  echo       "$__UN_$__W_$__BGK_                  COLORS                                 $__NN_ "
  echo
  env | grep "^TARTIFY_COLOR" | sort -df \
      | awk -F"=" '{printf("%'11s'%'0s'%-'48s'%'0s'\n", "\033[0m    ",$2,($1 "\033[0m")," ")}'
  echo;echo
  echo $__NN_"   \`tartify help\` for more";
  echo $__NN_"   \`tartitune help\` for more";
}


__tartify_build_PS1() {
  #WARN: this is called from within the PS1 string, hence we're in a
  #      subshell -> no exporting
  local argstr="$*"
  local before=""
  local after=""

  [[ "$argstr" =~ W ]] && printf "%s" '$__t4_newline_before'

  # tartiforce session
  printf "%s" '\['$__EMY_'\]$__t4_force\['$__NN_'\]'
  # tartitune session
  printf "%s" '\['$__EMR_'\]$__t4_tune\['$__NN_'\]'

  local firstn="true" #don't insert dynamic separator ($__t4_sep*) before first item
  local delimNb=0     #delimiter's position
  for ((n=0;n<${#argstr};n++))
  do
    local ch="${argstr:$n:1}"
    case "$ch" in
      n | N | m | M)
        #REPO NAME
        [ -z "$firstn" ] && printf "%s" '$__t4_sepN'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_REPO_NAMEALONE'\]$__t4_rep'
        printf "%s" '\['$TARTIFY_COLOR_REPO_NAMEBASE'\]$__t4_nrep\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_REPO_LOCALPATH'\]$__t4_lpath'
        printf "%s" '\['$__NN_'\]'

        # NOCOLORS option
        printf "%s" '$__t4_ncrep'

        unset firstn
        ;;
      a | A )
        #ANCESTOR NAME
        [ -z "$firstn" ] && printf "%s" '$__t4_sepA'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_ANCESTOR_NAME'\]$__t4_anc'
        printf "%s" '\['$__NN_'\]'

        # NOCOLORS option
        printf "%s" '$__t4_ncanc'

        unset firstn
        ;;
      b | B | o)
        #BRANCH
        [ -z "$firstn" ] && printf "%s" '$__t4_sepB'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_BARE'\]$__t4_bare'

        #no untracked files
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_tU''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_tuSr''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_tRA''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_tRD''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_tRI''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_tRO''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_tRN''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_turS''\['$__NN_'\]'

        #untracked files
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UNSTAGED'\]$__t4_TU''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TuSr''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD'\]$__t4_TRA''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND'\]$__t4_TRD''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE'\]$__t4_TRI''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE'\]$__t4_TRO''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK'\]$__t4_TRN''\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_STYLE_BRANCH_UNTRACKED'\]'
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_STAGED'\]$__t4_TurS'
        printf "%s" '\['$__NN_'\]'

        #merge infos
        printf "%s" '\['$TARTIFY_COLOR_BRANCH_MERGEINFOS'\]$__t4_merg'
        printf "%s" '\['$__NN_'\]'

        # NOCOLORS branch
        printf "%s" '$__t4_ncbare$__t4_ncbranch$__t4_ncmerg'
        # OLDSCHOOL branch
        printf "%s" '$__t4_oldschool'

        unset firstn
        ;;
      r | R)
        #REMOTES
        [ -z "$firstn" ] && printf "%s" '$__t4_sepR'
        printf "%s" '\['$__NN_'\]$__t4_rOrsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_ORIGIN'\]$__t4_rOt$__t4_rOn$__t4_rO1p'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_AHEAD'\]$__t4_rOac'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_ORIGIN'\]$__t4_rOcsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_BEHIND'\]$__t4_rObc'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_ORIGIN'\]$__t4_rO2p'
        printf "%s" '\['$__NN_'\]$__t4_rUrsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM'\]$__t4_rUt$__t4_rUn$__t4_rU1p'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_AHEAD'\]$__t4_rUac'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM'\]$__t4_rUcsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_BEHIND'\]$__t4_rUbc'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM'\]$__t4_rU2p'
        printf "%s" '\['$__NN_'\]$__t4_r1rsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r1t$__t4_r1n$__t4_r11p'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_AHEAD'\]$__t4_r1ac'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r1csep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_BEHIND'\]$__t4_r1bc'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r12p'
        printf "%s" '\['$__NN_'\]$__t4_r2rsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r2t$__t4_r2n$__t4_r21p'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_AHEAD'\]$__t4_r2ac'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r2csep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_BEHIND'\]$__t4_r2bc'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r22p'
        printf "%s" '\['$__NN_'\]$__t4_r3rsep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r3t$__t4_r3n$__t4_r31p'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_AHEAD'\]$__t4_r3ac'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r3csep'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_COUNT_BEHIND'\]$__t4_r3bc'
        printf "%s" '\['$TARTIFY_COLOR_REMOTE_NAME_OTHER'\]$__t4_r32p'
        printf "%s" '\['$__NN_'\]'
        # NOCOLORS option
        printf "%s" '$__t4_ncremotes'

        unset firstn
        ;;
      s | S)
        #STASHES
        [ -z "$firstn" ] && printf "%s" '$__t4_sepS'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_STASH_NOCOUNT'\]$__t4_st'
        printf "%s" '\['$TARTIFY_COLOR_STASH_COUNT'\]$__t4_ST'
        printf "%s" '\['$__NN_'\]'
        printf "%s" '$__t4_ncstash'
        printf "%s" '$__t4_ncSTASH'

        unset firstn
        ;;
      l | L)
        #LAST COMMIT
        [ -z "$firstn" ] && printf "%s" '$__t4_sepL'
        printf "%s" '\['$__NN_'\]'
        #COULD COMMIT
        printf "%s" '\['$TARTIFY_STYLE_TIME_COULDCOMMIT'\]'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lccan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lccal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lccah'
        printf "%s" '\['$__NN_'\]'
        #SHOULD COMMIT
        printf "%s" '\['$TARTIFY_STYLE_TIME_SHOULDCOMMIT'\]'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lscan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lscal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lscah'
        printf "%s" '\['$__NN_'\]'
        # NO HURRY
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_NONE'\]$__t4_lnhan'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_LOW'\]$__t4_lnhal'
        printf "%s" '\['$TARTIFY_COLOR_TIME_ACTIVITY_HIGH'\]$__t4_lnhah'
        printf "%s" '\['$__NN_'\]'
        # NOCOLORS option
        printf "%s" '$__t4_nclast'

        unset firstn
        ;;
      c) ;;
      d)
        #SMART PWD
        #(always on its own, so no [ -z "$firstn" ] test)
        printf "%s" '\['$__NN_'\]'
        printf "%s" '\['$TARTIFY_COLOR_PWD'\]$__t4_pwd'
        ;;
      o) ;;
      p) ;;
      f) ;;
      i) ;;
      a) ;;
      q) ;;
      t) ;;
      v) ;;
      w) ;;
      W) ;;
      I) ;;
      0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ;;
      #TODO: make that work with PS1 and NOCOLORS
      #*) printf "%s" '\['$TARTIFY_COLOR_MISC_DELIMITER'\]'$ch'\['$__NN_'\]';;
      *)
        #Delimiters will be generated and stored dynamically in __t4_D* variables for each
        #call of 'tartify q'
        # 0  .. 49 : colored
        # 50 .. 99 : nocolored
        printf "%s" '\['"$TARTIFY_COLOR_MISC_DELIMITER"'\]$__t4_D'"$delimNb"'\['$__NN_'\]'
        printf "%s" '$__t4_D'$(($delimNb + 50))
        delimNb=$((delimNb + 1))
        ;;
    esac
  done


  printf "%s" '\['$__NN_'\]'

  [[ "$argstr" =~ w ]] && printf "%s" '$__t4_newline_after'

  #TODO: newline insertion


}


__tartify_popup ()
{

  #  position the 'tartify()' result on the screen
  #   ┌───────────────┐
  #   │1      2      3│
  #   │4      5      6│
  #   │7      8      9│
  #   │               │
  #   │               │
  #   │              0│
  #   └───────────────┘

  #TODO: next test is not necessary
  #[ -z "$menuPos" ] && menuPos="3" #default : top right corner

  #TODO: NOCOLORS for delimiters !!
  #result=$(tartify "n/b - l");
  local border=$__NN_$__B_;
  tput sc;
  if [ -z "$tartanswer" ]; then
    :;
  else
    local stripansi=$(printf "%s" "$tartanswer" | perl -pe 's/\e\[?.*?[\@-~]//g');
    local resLength=$((${#stripansi} + 4));
    local menuBorderTop=$(printf "%s" "$stripansi""##" | tr "[:print:]" $TARTIFY_STRING_MENU_TOP);
    local menuBorderBottom=$(printf "%s" "$stripansi""##" | tr "[:print:]" $TARTIFY_STRING_MENU_BOTTOM);

    local blankLine=$(printf "%s" "$stripansi""####")
    blankLine=$(printf "%${#blankLine}s")
    ##much slower alternative :
    #local blankLine=$(printf "%s" $stripansi"    " | tr "[:print:]" ' ');

    local firstC=
    local firstL=
    local oneliner=
    local additLines=
    local sttysize=
    local nlines=
    local ncol=

    sttysize=$(stty size 2>/dev/null)
    [ $? -eq 0 ]  && {
      nlines=${sttysize%% *}
      ncol=${sttysize##* }
    } || {
      nlines=$(tput lines);
      ncol=$(tput cols);
    }


    case $menuPos in

      1) firstL=0                 ; firstC=0                                              ;;
      2) firstL=0                 ; firstC=$(( ($ncol - $resLength)/2 ))                  ;;
      3) firstL=0                 ; firstC=$((  $ncol - $resLength ))                     ;;
      4) firstL=1                 ; firstC=0                            ; additLines=1    ;;
      5) firstL=1                 ; firstC=$(( ($ncol - $resLength)/2 )); additLines=1    ;;
      6) firstL=1                 ; firstC=$((  $ncol - $resLength ))   ; additLines=1    ;;
      7) firstL=2                 ; firstC=0                            ; additLines=2    ;;
      8) firstL=2                 ; firstC=$(( ($ncol - $resLength)/2 )); additLines=2    ;;
      9) firstL=2                 ; firstC=$((  $ncol - $resLength ))   ; additLines=2    ;;
      0) firstL=$(( $nlines - 1 )); firstC=$((  $ncol - $resLength ))   ; additLines=2 ; oneliner="true" ;;

    esac

    [ -z "$additLines" ] || {
      [ 2 -le $additLines ] && {
      tput cup $(($firstL - 2)) $firstC;
        printf "%s" "$__NN_$blankLine";
      }

      [ 1 -le $additLines ] && {
      tput cup $(($firstL - 1)) $firstC;
        printf "%s" "$__NN_$blankLine";
      }
    }

    [ -z "$oneliner" ] && {
      tput cup $firstL $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_TOPLEFT$menuBorderTop$TARTIFY_STRING_MENU_TOPRIGHT$__NN_";
      tput cup $(($firstL + 1)) $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_LEFT$__NN_" "$tartanswer" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_RIGHT$__NN_";
      tput cup $(($firstL + 2)) $firstC;
      printf "%s" "$TARTIFY_COLOR_MENU_BORDER$TARTIFY_STRING_MENU_BOTTOMLEFT$menuBorderBottom$TARTIFY_STRING_MENU_BOTTOMRIGHT$__NN_";
    } || {
      tput cup $(($firstL )) $(($firstC + 4));
      printf "%s" "$__NN_$tartanswer$__NN_";
    }


    tput rc;
    #echo "stty-size=$(stty size) - nlines=$nlines ($(tput lines)) - ncol=$ncol ($(tput cols)) - firstL=$firstL - firstC=$firstC - resLength=$resLength - stripansi=$stripansi - menuBorder=["$menuBorder"]"
  fi;
  #echo "nlines=$nlines - ncol=$ncol - firstL=$firstL - firstC=$firstC - resLength=$resLength - stripansi=$stripansi - menuBorder=["$menuBorder"]"
  #stty size
}


__tartify_reformat_timestamp(){
# prints a relative-formatted time string from unix timestamp
# arg: unix timestamp in seconds
# optional arg: true to include coloring
# copied from https://github.com/xtrementl/dev-bash-git-ps1.git
    local secs="$1"
    local yrs="$(( $secs / 31557600 ))"
    local div="$(( $secs % 31557600 ))"
    local days="$(( div / 86400 ))"
    div="$(( $secs % 86400 ))"
    local hrs="$(( $div / 3600 ))"
    div="$(( $secs % 3600 ))"
    local mins="$(( $div / 60 ))"

    # create the formatted time string
    [ 0 -lt "$yrs" ] && timestr="${yrs}y"
    [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    if [ 0 -lt "$days" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${days}d"
        [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    fi
    if [ 0 -lt "$hrs" ]; then
        [ -n "$timestr" ] && timestr="$timestr,"
        timestr="${timestr}${hrs}h"
        [ -n "$timestr" ] && [ "SHORT" = $TARTIFY_SETTING_TIME_DISPLAY ] && return 0
    fi
    [ -n "$timestr" ] && timestr="${timestr},"
    timestr="${timestr}${mins}m"

}


__tartify_smart_PWD(){

  # How many characters of the $PWD should be kept
  local pwdmaxlen=$TARTIFY_SETTING_PWD_MAXLEN
  # Indicate that there has been dir truncation
  local dir=${PWD##*/}
  pwdmaxlen=$(( ( pwdmaxlen < ${#dir} ) ? ${#dir} : pwdmaxlen ))
  NEW_PWD=${PWD/#$HOME/\~}
  local pwdoffset=$(( ${#NEW_PWD} - pwdmaxlen ))
  if [ ${pwdoffset} -gt "0" ]
  then
      NEW_PWD=${NEW_PWD:$pwdoffset:$pwdmaxlen}
      NEW_PWD=${TARTIFY_STRING_PWD_TRUNCSYMBOL}/${NEW_PWD#*/}
  fi
  echo $NEW_PWD


}


__tartify_smart_repopath(){

  [ -z "$1" ] || {
    NEW_PWD="$1"
    # How many characters of the $PWD should be kept
    local pwdmaxlen=$TARTIFY_SETTING_REPO_NAMEMAXLEN
    # Indicate that there has been dir truncation
    local dir=${1##*/}
    pwdmaxlen=$(( ( pwdmaxlen < ${#dir} ) ? ${#dir} : pwdmaxlen ))
    local pwdoffset=$(( ${#NEW_PWD} - pwdmaxlen ))
    if [ ${pwdoffset} -gt "0" ]
    then
        NEW_PWD=${NEW_PWD:$pwdoffset:$pwdmaxlen}
        NEW_PWD=${TARTIFY_STRING_PWD_TRUNCSYMBOL}/${NEW_PWD#*/}
    fi
    echo $NEW_PWD
  }

}


#------------------------------------------------------------------------------
#
#             The 5 TARTIFY command(ement)s
#
# All the following functions are intended for use from the tartify command and
# assume we are inside a GIT repository.
#
#------------------------------------------------------------------------------


__tartify_repo_name()
{

  #PS1 dynamic separator
  [ ! -z "$forceSeparator" ] &&  [ ! -z "$reponame" ] && __t4_sepN="$separator"

  #NOCOLORS
  [ "true" = $nocolors ] &&  {
    [ "true" = "$includelocalpath" ] && __t4_ncrep="$reponame$(__tartify_smart_repopath $localpath)" ||  __t4_ncrep="$reponame"
    if [ -z "$splitargstr" ]; then
      tartanswer="$tartanswer$__t4_ncrep"
    else
      #SPLIT output TEST
      if [[  "$splitargstr" =~ n  ]] || [[  "$splitargstr" =~ N  ]]; then
        tartanswer="$tartanswer$__t4_ncrep"
        __tartify_reset_PS1_globs NAME
      fi
    fi

  } || {
  #COLORS
    #WITH LOCAL PATH
    [ "true" = "$includelocalpath" ] && { __t4_lpath="$(__tartify_smart_repopath $localpath)"; __t4_nrep="$reponame"; } || __t4_rep="$reponame"
    if [ -z "$splitargstr" ]; then
      if [ "true" = "$includelocalpath" ]; then
        tartanswer="$tartanswer$TARTIFY_COLOR_REPO_NAMEBASE$reponame${__NN_}$TARTIFY_COLOR_REPO_LOCALPATH$(__tartify_smart_repopath $localpath)${__NN_}"
      else
        tartanswer="$tartanswer$TARTIFY_COLOR_REPO_NAMEALONE$reponame${__NN_}"
      fi
    #NO LOCAL PATH
    else
      #SPLIT output TEST
      if [[  "$splitargstr" =~ n  ]] || [[  "$splitargstr" =~ N  ]]; then
        if [ "true" = "$includelocalpath" ]; then
          tartanswer="$tartanswer$TARTIFY_COLOR_REPO_NAMEBASE$reponame${__NN_}$TARTIFY_COLOR_REPO_LOCALPATH$(__tartify_smart_repopath $localpath)${__NN_}"
        else
          tartanswer="$tartanswer$TARTIFY_COLOR_REPO_NAMEALONE$reponame${__NN_}"
        fi
        __tartify_reset_PS1_globs NAME
      fi
    fi
  }
}

__tartify_ancestor() {
  # in case of a submodule, we print : 
  # * the parent repo name, or
  # * a symbol reminding that we're in a submodule
  #
  # NB/ we assume we already are inside a GIT repo

  local parentreponame=

  #[ $isbare = "false" ] && {
    parentreponame=$(
      localpath2="$repopath/.."
      cd "$localpath2"
      hasanc=$(git rev-parse --git-dir 2>/dev/null)
      if [ $? -eq 0 ]; then
        repopath2=${hasanc%%/.git}

        [ ".git" = "$repopath2" ] && repopath2="$localpath2"
        [ "." = "$repopath2" ] && repopath2="$localpath2"
        reponame2="${repopath2##*/}"

        # child repo present in .gitmodules ?
        cd $repopath2
        cat .gitmodules | grep $reponame >/dev/null 2>&1
        [ $? -eq 0 ] || printf "%s" "$TARTIFY_STRING_ANCESTOR_NOSUB"
        [ -z "$TARTIFY_STRING_ANCESTOR_MARKER" ] && printf "%s" "$reponame2" || printf "%s" "$TARTIFY_STRING_ANCESTOR_MARKER"
      fi
    )
  #}

  #PS1 dynamic separator
  [ ! -z "$forceSeparator" ] &&  [ ! -z "$parentreponame" ] && __t4_sepA="$separator"

  #NOCOLORS
  [ "true" = $nocolors ] &&  {
    __t4_ncanc="$parentreponame"
    if [ -z "$splitargstr" ]; then
      tartanswer="$tartanswer$__t4_ncanc"
    else
      #SPLIT output TEST
      if [[  "$splitargstr" =~ n  ]] || [[  "$splitargstr" =~ N  ]]; then
        tartanswer="$tartanswer$__t4_ncanc"
        __tartify_reset_PS1_globs ANCESTOR
      fi
    fi
  } || {
  #COLORS
    __t4_anc="$parentreponame"
    if [ -z "$splitargstr" ]; then
      tartanswer="$tartanswer$TARTIFY_COLOR_ANCESTOR_NAME$__t4_anc"
    else
      #SPLIT output TEST
      if [[  "$splitargstr" =~ n  ]] || [[  "$splitargstr" =~ N  ]]; then
        tartanswer="$tartanswer$TARTIFY_COLOR_ANCESTOR_NAME$__t4_anc"
        __tartify_reset_PS1_globs ANCESTOR
      fi
    fi
  }

}


#TODO: nocolors
# __t4_ncbranch
# printf "%s" '$__t4_bare$__t4_ncbranch$__t4_merg'
__tartify_branch(){
  # OLDSCHOOL _mode : output the same exact string __git_ps1 would
  #
  # VIM _mode
  #
  #   Return value:
  #
  #       $nci\|$branchname\|$merge_status
  #
  #     nci =~ /[U]?[S]?[IDAONGBE][T]?/    (nci : no colors info)
  #
  #        [U]nstaged modif(s)
  #
  #        [S]taged modif(s)
  #
  #       d[I]verged from remote
  #   behin[D] remote
  #        [A]head of remote
  #        [O]K (remote == HEAD)
  #        [N]o tracked remote
  #        [G]it directory
  #        [B]are repository
  #        [E]mpty repository
  #
  #        un[T]racked files,
  #
  #     merge_infos : either one of these values, or "" :
  #
  #        REBASE-i, REBASE-m, REBASE, AM, AM/REBASE, MERGING, CHERRY-PICKING,
  #        BISECTING
  #
  # QUIET _mode
  #
  # PS1 _mode
  #
  #   will use on-the-fly variable-NAMES creation
  #
  #     TOTO=2
  #     TATA=TO
  #     TITI=$(eval "printf "%s" "\$${TATA}TO"")

  if [ "OLDSCHOOL" = "$branchstyle" ]; then
    local f="$w$i$s$u"
    #printf "%s" "$c${b##refs/heads/}${f:+ $f}$r$p"
    __t4_oldschool="$c${b##refs/heads/}${f:+ $f}$r$p"
    [ -z "$splitargstr" ] && tartanswer="$tartanswer$__t4_oldschool" || {
      #SPLIT output TEST
      [[  "$splitargstr" =~ o  ]] && { tartanswer="$tartanswer$__t4_oldschool"; __tartify_reset_PS1_globs BRANCH; }
    }
    #
    #printf "%s" "$c   ${b##refs/heads/}${f:+ $f}$r$p"
    #             $c   $b               $w       $i     $s    $u        $r           $p
    #             BARE:master           unstaged staged stash untracked rebase/merge upstream
    #
    #             [ branch name ]       [red]    [**]   [OLDSC] [underl] [??]
  else
    case $mode in

      VIM)
        #IDAONGBE : SGBE already taken care of by __tartify_git_ps1()
        #          Determine AON (tracking branch info)
        #
        #          As S overrides all other IDAONGBE states, begin with this:
        case $p in
          '<>') idaongbe="I"  ;;
          '<')  idaongbe="D"  ;;
          '>')  idaongbe="A"  ;;
          '=')  idaongbe="O"  ;;
          *)    idaongbe="N"  ;;
        esac
        #NOCOLORSINFOS ($nci)
        local nci=$idaongbe
        [ -n "$w" ]      && nci=$nci"U"  #unstaged
        [ "+" =  "$i" ]  && nci=$nci"S"  #staged
        [ -n "$u" ]      && nci=$nci"T"  #untracked
        #RESULT
        tartanswer="$tartanswer$nci|${b##refs/heads/}$r" #$r already includes the "|" separator
      ;;


      #HANDLED SEPARATELY
      PS1)
      ;;


      #TODO: SHORT/LONG options
      #TODO: *) would be better
      NORMAL | QUIET)
        local bname=${b##refs/heads/}
        local bnameL=${#bname}

        # -- COLORS --
        if [ "false" = $nocolors ]; then
          # determine "remote info" color
          local prefix=""  # stores prefix for dynamic '__t4_' variable generation (QUIET mode)
          local bColRemote="" # stores color used in NORMAL mode
          case $p in
            '<>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_DIVERGE  ; prefix="I" ;;
            '<')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_BEHIND   ; prefix="D" ;;
            '>')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_AHEAD    ; prefix="A" ;;
            '=')  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_UPTODATE ; prefix="O" ;;
              *)  bColRemote=$TARTIFY_COLOR_BRANCH_UPSTREAM_NOTRACK  ; prefix="N" ;;
          esac
          local colUntracked=
          [ -n "$u" ] && colUntracked=$TARTIFY_STYLE_BRANCH_UNTRACKED

          # concatenate some
          local Unst=$__NN_$TARTIFY_COLOR_BRANCH_UNSTAGED$colUntracked
          local Stag=$__NN_$TARTIFY_COLOR_BRANCH_STAGED$colUntracked
          local Remo=$__NN_$bColRemote$colUntracked

          local ll=$TARTIFY_SETTING_BRANCH_STAGED_INFOLENGTH
          local remaind
          local res1=""; local res2=""; local res3=""

          # CASE1 both Staged and Unstaged changes
          if [ -n "$w" ] && [ "+" = "$i" ]; then
              remaind=$(($bnameL - ((2 * $ll)) ))
              [ $(($remaind <= 0)) -eq 1  ] && { remaind=$(($bnameL % 2)); ll=$(($bnameL / 2)) ; }

              [ -z "$TARTIFY_SETTING_BRANCH_STAGED_INFO" ] && {
                  #URS [m]aste[r],[ma]st[er] ,[mas][ter], ...
                  res1=${bname:0:$ll}
                  res2=${bname:$ll:$remaind}
                  res3=${bname:(($remaind + $ll )):$ll}
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\"\$res2\"" ; __t4_TurS=$res3; } ||
                                  { __t4_tU=$res1; eval "__t4_tR$prefix=\"\$res2\"" ; __t4_turS=$res3; }
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Remo$res2; res3=$Stag$res3$__NN_
              } || {
                  #USR [m][a]ster, [ma][st]er, [mas][ter], ...
                  res1=${bname:0:$ll}
                  res2=${bname:$ll:$ll}
                  res3=${bname:(($ll * 2)):$remaind}
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TU=$res1; __t4_TuSr=$res2; eval "__t4_TR$prefix=\"\$res3\""; } ||
                                  { __t4_tU=$res1; __t4_tuSr=$res2; eval "__t4_tR$prefix=\"\$res3\""; }
                  #colors for NORMAL mode
                  res1=$Unst$res1; res2=$Stag$res2; res3=$Remo$res3$__NN_
              }

          # CASE2 only Unstaged changes
          elif [ -n "$w" ]; then
              remaind=$(($bnameL -  $ll))
              [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }

              #URS & UR (m)aster,(ma)ster ,(mas)ter, ...
              res1=${bname:0:$ll}
              res2=${bname:$ll:$remaind}
              #update PS1 vars
              [ -n "$u" ] &&  { __t4_TU=$res1; eval "__t4_TR$prefix=\"\$res2\""; } ||
                              { __t4_tU=$res1; eval "__t4_tR$prefix=\"\$res2\""; }
              #colors for NORMAL mode
              res1=$Unst$res1; res2=$Remo$res2$__NN_

          # CASE3 only Staged changes
          elif [ "+" = "$i" ]; then
              remaind=$(($bnameL -  $ll  ))
              [ $(($remaind <= 0)) -eq 1  ] && { remaind=1; ll=$(($bnameL - 1)) ; }
              [ -z "$TARTIFY_SETTING_BRANCH_STAGED_INFO" ] && {
                  #RS maste[r],mast[er] ,mas[ter], ...
                  res1=${bname:0:$remaind}
                  res2=${bname:$remaind:$ll}
                  #update PS1 vars
                  [ -n "$u" ] &&  { eval "__t4_TR$prefix=\"\$res1\"" ; __t4_TurS=$res2; } ||
                                  { eval "__t4_tR$prefix=\"\$res1\"" ; __t4_turS=$res2; }
                  #colors for NORMAL mode
                  res1=$Remo$res1; res2=$Stag$res2$__NN_
              } || {
                  #SR [m]aster, [ma]ster, [mas]ter, ...
                  res1=${bname:0:$ll}
                  res2=${bname:$ll:$remaind}
                  #update PS1 vars
                  [ -n "$u" ] &&  { __t4_TuSr=$res1; eval "__t4_TR$prefix=\"\$res2\""; } ||
                                  { __t4_tuSr=$res1; eval "__t4_tR$prefix=\"\$res2\""; }
                  #colors for NORMAL mode
                  res1=$Stag$res1; res2=$Remo$res2$__NN_
              }
          # CASE4 no changes in index
          else
            res1=$bname
            #update PS1 vars
            [ -n "$u" ] &&  { eval "__t4_TR$prefix=\"\$res1\""; } ||
                            { eval "__t4_tR$prefix=\"\$res1\""; }
            #colors for NORMAL mode
            res1=$Remo$res1$__NN_
          fi

          #PS1 dynamic separator
          #[ -z "$forceSeparator" ] || { [ ! -z "$bname" ] && __t4_sepB="$separator" ;}
          [ ! -z "$forceSeparator" ] &&  [ ! -z "$bname" ] && __t4_sepB="$separator"

          #[ ! -z $r ] && __t4_merg=$r  #mergeinfos
          #[ ! -z $c ] && __t4_bare=$c  #bare
          __t4_merg=$r  #mergeinfos
          __t4_bare=$c  #bare

          [ -z "$splitargstr" ] && tartanswer="$tartanswer$c$res1$res2$res3$TARTIFY_COLOR_BRANCH_MERGEINFOS$r$__NN_" || {
            #SPLIT output TEST
            if [[  "$splitargstr" =~ b  ]] || [[  "$splitargstr" =~ B  ]]; then
              tartanswer="$tartanswer$c$res1$res2$res3$TARTIFY_COLOR_BRANCH_MERGEINFOS$r$__NN_"
              __tartify_reset_PS1_globs BRANCH
            fi
          }

        # -- NOCOLORS --
        else
          __t4_ncbare=$c
          __t4_ncbranch=$bname
          __t4_ncmerg=$r

          tartanswer="$tartanswer$c$bname$r"
        fi


      ;;
    esac
  fi

  return 0

}

#TODO:
# __t4_ncremotes

# additional cost 7/8ms per remote
__tartify_remote(){
  [ "OLDSCHOOL" = "$mode" ] && return 0

  local branchname=${b##refs/heads/}
    # ------- REMOTES INFO ( + BRANCH TRACKED ) --------
    local remName
    local marker_color
    local before_traked=""

    local ps1varRadical
    local nbRemotes=0
    local firstRemote="true"
    local nbOtherRemotes=0

    # loop through remotes

    #PROPER (new) syntax, but for compatibility with git 1.5.4.3 & before, we instead use :
    for remotename in $(git remote show); do
    #for remotename in $(git remote); do
      (( nbRemotes++))

      # special markers for origin and upstream
      # nb: a tracked remote is preceded by a little ➝ symbol
      case $remotename in
          origin) remName="$TARTIFY_STRING_REMOTE_ORIGIN"
                  marker_color=$TARTIFY_COLOR_REMOTE_NAME_ORIGIN
                  ps1varRadical='__t4_rO'
                  ;;
        upstream) remName="$TARTIFY_STRING_REMOTE_UPSTREAM"
                  marker_color=$TARTIFY_COLOR_REMOTE_NAME_UPSTREAM
                  ps1varRadical='__t4_rU'
                  ;;
               *) remName="$TARTIFY_STRING_REMOTE_OTHER"
                  marker_color=$TARTIFY_COLOR_REMOTE_NAME_OTHER
                  nbOtherRemotes=$(($nbOtherRemotes + 1))
                  ps1varRadical="__t4_r$nbOtherRemotes"
                  ;;
      esac

      # Insert inter-remote separator except 1st one
      [ -z "$TARTIFY_STRING_REMOTE_SEP" ] || [ "true" = "$firstRemote" ] || {
        [ "false" = "$nocolors" ] &&  eval "${ps1varRadical}rsep=\"$TARTIFY_STRING_REMOTE_SEP\""
      }
      firstRemote="false"

      # Tracking Branch remName
      if [ "$remotename" = "$(git config --get branch.$branchname.remote)" ]
      then
        [ "false" = "$nocolors" ] &&  before_traked="$marker_color"
        before_traked="$before_tracked$TARTIFY_STRING_REMOTE_TRACKING";
        #before_traked="$marker_color$TARTIFY_STRING_REMOTE_TRACKING";

        #PS1: tracking symbol
        [ "false" = "$nocolors" ] &&  eval "${ps1varRadical}t=\"$TARTIFY_STRING_REMOTE_TRACKING\""
      fi

      #PS1: remote name
      [ "false" = "$nocolors" ] &&  eval "${ps1varRadical}n=\"$remName\""

      # nb of commits AHEAD/BEHIND
      local ahead_count="$(__tartify_diff_count $remotename/$branchname HEAD)"
      local behind_count="$(__tartify_diff_count HEAD $remotename/$branchname)"
      local diffcount=""
      local diffcountnocol=""


      [ $(($ahead_count + $behind_count)) -eq 0 ] || {
        local paren1=
        local paren2=
        if [ -z "$TARTIFY_STRING_REMOTE_1STPAREN" ];then paren1="("
        elif [ " " != "$TARTIFY_STRING_REMOTE_1STPAREN" ]; then paren1=$TARTIFY_STRING_REMOTE_1STPAREN
        fi
        if [ -z "$TARTIFY_STRING_REMOTE_2NDPAREN" ];then paren2=")"
        elif [ " " != "$TARTIFY_STRING_REMOTE_2NDPAREN" ]; then paren2=$TARTIFY_STRING_REMOTE_2NDPAREN
        fi

        #PS1 : parens
        [ "false" = $nocolors ] && {
          eval "${ps1varRadical}1p=\"$paren1\""
          eval "${ps1varRadical}2p=\"$paren2\""
        }

        if [ 0 -lt "$ahead_count" ]; then
          diffcount="${TARTIFY_COLOR_REMOTE_COUNT_AHEAD}${ahead_count}"
          diffcountnocol="+${ahead_count}"
          #PS1: ahead count
          [ "false" = $nocolors ] &&  eval "${ps1varRadical}ac=\"$ahead_count\""
        fi

        if [ 0 -lt "$behind_count" ]; then
          #separator only if both $ahead_count AND $behind_count not null
          [ -n "$diffcount" ] && {
            diffcount="${diffcount}${marker_color}$TARTIFY_STRING_REMOTE_COUNTSEP"
            diffcountnocol="${diffcountnocol}$TARTIFY_STRING_REMOTE_COUNTSEP"
            #PS1 : separator
            [ "false" = $nocolors ] &&  eval "${ps1varRadical}csep=\"$TARTIFY_STRING_REMOTE_COUNTSEP\""
          }
          diffcount="${diffcount}${TARTIFY_COLOR_REMOTE_COUNT_BEHIND}${behind_count}"
          diffcountnocol="${diffcountnocol}-${behind_count}"
          #PS1: behind count
          [ "false" = $nocolors ] &&  eval "${ps1varRadical}bc=\"$behind_count\""
        fi

        [ -n "$diffcount" ] && diffcount=" ${marker_color}($diffcount${marker_color}) "
        [ -n "$diffcountnocol" ] && diffcountnocol=" ($diffcountnocol) "
      }

      # RESULT
      [ "true" = $nocolors ] &&  {
        __t4_ncremotes="${before_traked}${remName}${diffcountnocol}"

        [ -z "$splitargstr" ] && tartanswer="${tartanswer}$__t4_ncremotes" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ r  ]] || [[  "$splitargstr" =~ R  ]];then
            tartanswer="${tartanswer}$__t4_ncremotes"
            __tartify_reset_PS1_globs REMOTE
          fi
        }

      } || {

        [ -z "$splitargstr" ] && tartanswer="${tartanswer}${marker_color}${before_traked}${remName}${diffcount}${__NN_}" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ r  ]] || [[  "$splitargstr" =~ R  ]]; then
            tartanswer="${tartanswer}${marker_color}${before_traked}${remName}${diffcount}${__NN_}"
            __tartify_reset_PS1_globs REMOTE
          fi
        }

      }
    done

    #PS1 dynamic separator
    [ ! -z "$forceSeparator" ] &&  [ 0 -lt "$nbRemotes" ] && __t4_sepR="$separator"

}


#TODO:
# __t4_ncstash
__tartify_stash()
{
  [ "OLDSCHOOL" = "$mode" ] && return 0
  #[ "QUIET" = "$mode" ]     && __tartify_reset_PS1_globs "STASH"

  local color
  local stashstr
  #? are we inside a GIT repo's working tree
  if [ "true" = "$isinsideworktree" ]; then
    if [ "true" = "$hasstash" ]; then
      if [ -n "$TARTIFY_SETTING_STASH_COUNT" ]; then
        # One star per stash
        color=$TARTIFY_COLOR_STASH_COUNT
        #stashcount="  "
        local n
        #! `git stash list | wc -l` adds about 50ms
        local stashcount
        # 'git stash count' might be more portable but about 20 times slower
        [ -f "$g/logs/refs/stash" ] && stashcount=$( cat $g/logs/refs/stash | wc -l) || stashcount=$(git stash list | wc -l)
        for (( n=0; n< $stashcount; n++ ))
        do
          stashstr=$stashstr$TARTIFY_STRING_STASH
        done
        #stashstr=$stashstr" "
        #QUIET mode
        [ "true" = $nocolors ] && __t4_ncSTASH=$stashstr || __t4_ST=$stashstr
      else
        color=$TARTIFY_COLOR_STASH_NOCOUNT
        stashstr=$TARTIFY_STRING_STASH
        #QUIET mode
        [ "true" = $nocolors ] &&  __t4_ncstash=$stashstr || __t4_st=$stashstr
      fi
      color=$color$stashstr${__NN_}

      #PS1 dynamic separator
      [ ! -z "$forceSeparator" ] &&  [ ! -z "$stashstr" ] && __t4_sepS="$separator"
    fi
    [ "true" = $nocolors ] &&   {

        [ -z "$splitargstr" ] && tartanswer="$tartanswer$stashstr" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ s  ]] || [[  "$splitargstr" =~ S  ]]; then
            tartanswer="$tartanswer$stashstr"
            __tartify_reset_PS1_globs STASH
          fi
        }

    } || {

        [ -z "$splitargstr" ] && tartanswer="$tartanswer$color" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ s  ]] || [[  "$splitargstr" =~ S  ]]; then
            tartanswer="$tartanswer$color"
            __tartify_reset_PS1_globs STASH
          fi
        }

    }
  fi
}


__tartify_timelastcommit(){

  local color

  # calc relative time diff of last commit
  local secs="$(
    # get the unix timestamp for the lastest commit (seconds)
    # copied from https://github.com/xtrementl/dev-bash-git-ps1.git
        local now="$(date +%s)"
        local last_commit="$(git log --format='%at' -1 2>/dev/null)"
        if [ -z "$last_commit" ]; then # probably initial git init, no commits
            return
        fi
        if [ 0 -lt "$now" ] && [ 0 -lt "$last_commit" ]; then
            echo "$((now - last_commit))"
        fi
  )"

  if [ -n "$secs" ]; then
    local timestr
    [ "CHAR" = $TARTIFY_SETTING_TIME_DISPLAY ] && timestr=$TARTIFY_STRING_TIME_CHARDISPLAY ||
        __tartify_reformat_timestamp $secs #fills in timestr

    # Compute colors
    if [ "false" = $nocolors ]; then
      [ -n "$TARTIFY_SETTING_TIME_BUGME" ] && [ -n "$w$i" ] && { # $w:unstaged changes, $i: staged changes
          if [ $TARTIFY_SETTING_TIME_COULDCOMMIT -gt "$secs" ]; then
              if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then
                __t4_lnhan=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_NONE
              elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then
                __t4_lnhal=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_LOW
              else
                __t4_lnhah=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
              fi
          elif [ $TARTIFY_SETTING_TIME_SHOULDCOMMIT -gt "$secs" ]; then
              if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then
                __t4_lccan=${timestr}
                color=$TARTIFY_STYLE_TIME_COULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_NONE
              elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then
                __t4_lccal=${timestr}
                color=$TARTIFY_STYLE_TIME_COULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_LOW
              else
                __t4_lccah=${timestr}
                color=$TARTIFY_STYLE_TIME_COULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
              fi
          else
              if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then
                __t4_lscan=${timestr}
                color=$TARTIFY_STYLE_TIME_SHOULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_NONE
              elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then
                __t4_lscal=${timestr}
                color=$TARTIFY_STYLE_TIME_SHOULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_LOW
              else
                __t4_lscah=${timestr}
                color=$TARTIFY_STYLE_TIME_SHOULDCOMMIT$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
              fi
          fi
      } || {
              if [ $TARTIFY_SETTING_TIME_LOWACTIVITY -lt "$secs" ]; then
                __t4_lnhan=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_NONE
              elif [ $TARTIFY_SETTING_TIME_MEDIUMACTIVITY -lt "$secs" ]; then
                __t4_lnhal=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_LOW
              else
                __t4_lnhah=${timestr}
                color=$TARTIFY_COLOR_TIME_ACTIVITY_HIGH
              fi
      }

    # PS1 with nocolors
    else
        __t4_nclast=$timestr
    fi

    #TODO: empty if $timestr is empty ???
    #PS1 dynamic separator
    [ ! -z "$forceSeparator" ] &&  [ ! -z "$timestr" ] && __t4_sepL="$separator"
    #echo "forceSeparator=$forceSeparator - timestr=$timestr - __t4_sepL=$__t4_sepL"

    if [ "false" = "$nocolors" ]; then

        [ -z "$splitargstr" ] && tartanswer="$tartanswer$color$timestr$__NN_" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ l  ]] || [[  "$splitargstr" =~ L  ]]; then
            tartanswer="$tartanswer$color$timestr$__NN_"
            __tartify_reset_PS1_globs LAST
          fi
        }

    else

        [ -z "$splitargstr" ] && tartanswer="$tartanswer$timestr" || {
          #SPLIT output TEST
          if [[  "$splitargstr" =~ l  ]] || [[  "$splitargstr" =~ L  ]]; then
            tartanswer="$tartanswer$timestr"
            __tartify_reset_PS1_globs LAST
          fi
        }

    fi
  fi
}

#------------------------------------------------------------------------------
#
#             TARTIFY
#
#------------------------------------------------------------------------------


tartify()
{
#TODO: distinguish between FAST and SLOW modes to try and bypass a
#      maximum tests (VIM, OLDSCHOOL, ...)

  local argstr="$*"
  local forceSeparator="" # dynamic separator : whenever the only tartify options provided are those from
                          # ${TARTIFY_OPTIONS}, tartify will separate elements with (by default) a whitespace
                          # As soon as one or more separator is provided (that is any character that's not
                          # a tartify option), tartify won't use the dynamic separators

  # -- PARSE help options and exit --
  # do that first to enable testing if 'tartify' is present with exit
  # value of zero
  [[ "$argstr" =~ h ]] && { __tartify_usage "__tartify_Helpmsg"; return 0; }
  [[ "$argstr" =~ e ]] && { __tartify_show_env; return 0; }


  # -- Override args with $TARTIFY_FORCE --
  # * if $argstr is non empty,
  # * and there's no 'f' (force) option in the command line args,
  # * and we're not in VIM mode
  [[ "$argstr" =~ f ]] || {
      [ -n "$TARTIFY_FORCE" ] && {
          # ignore FORCE in VIM mode
          [[ "$argstr" =~ v ]] || argstr=$TARTIFY_FORCE
        }
  }


  # -- Force Automatic delimiter --
  local hasdelimiters=$(echo "$argstr" | tr -d $TARTIFY_OPTIONS)
  [ -z "$hasdelimiters" ] && forceSeparator=true
  #[ -z "$hasdelimiters" ] && echo "no delimiter" || echo "hasdelimiters=[$hasdelimiters]"


  # -- (optionnal) paramater expansion --
  if [ ${#argstr} -lt 3 ]; then
      #optionless
      if [ ${#argstr} -eq 0 ]; then
        argstr="nbrsl"                            #no args
      #mono-character options
      elif [ ${#argstr} -eq 1 ]; then
        case "$argstr" in
          v) argstr="vnbrsl";    ;; #vim
          p) argstr="pnbrsl";    ;; #PS1
          q) argstr="qnbrsl";    ;; #QUIET mode
          w) argstr="nbrslw";    ;; #newline after
          W) argstr="nbrslW";    ;; #newline before
          0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) argstr="${argstr}nbrsl"    ;; #menu mode
        esac
      #2-characters options
      else
        case "$argstr" in
          wW) argstr="nbrslwW" forceSeparator=true  ;; #newline BOTH
          Ww) argstr="nbrslwW" forceSeparator=true  ;; #newline BOTH
          #TODO: '1w', '3q',...
        esac
      fi
  fi


  # -- INIT tartify local vars --
  # Those are used in the whole tartify scope, from here on
  # (in __tartify_* functions)
  local tartanswer=""
  local localpath=""
  local repopath=""
  local reponame=""
  local isbare="false" #TODO: unused ? -> remove
  local isinsideworktree="false"
  local hasstash="false"
  local hasupstream="false"
  local nocolors=
  local forcenocolors="false"
  local includelocalpath="false"
  local mode="NORMAL"
  local branchstyle=""
  local menuPos=""
  local separator=
  local splitargstr=
  local splitanswer=

  local staged_info=""  # (VIM mode) branch status - store either one of these letters (US)
  local idaongbe=""     # (VIM mode) branch status - store either one of these letters (IDAONGBE)
  local pre_idaongbe="" # (VIM mode) branch status - store either one of these letters (US)
                        # used by __tartify_branch()

  local upstream=git legacy="" verbose=""  # moved here from original __git_ps1_showupstream
  local processupstream="false"  # check if current branch is tracked to a remote, and ahead/behind state
                                 # used by __tartify_branch()
                                 #         __tartify_remote()

  local processremotes="false"   # used by __tartify_remote()

  # -- INIT __git_ps1 locals --
  # Typical __git_PS1 variables
  # Those are used in the whole tartify scope, from here on
  # (in __tartify_* functions)
  local g=""   #GITDIR
  local r=""   #REBASE/MERGE/... info
  local b=""   #BRANCH
  local w=""   #UNSTAGED indicator "*"
  local i=""   #STAGED indicator "+"  or NO COMMIT YET in HEAD "#"
  local s=""   #STASH state $
  local u=""   #UNTRACKED files %
  local f=""   #"$w$i$s$u"  UNSTAGED STAGED STASH UNTRACKED
  local c=""   #BARE: prefix to $b (BRANCH)
  local p=""   #UPSTREAM info || empty string


  #force separator if need be
  [ -z "$forceSeparator" ] || {
    separator=$TARTIFY_STRING_MISC_SEPARATOR
  }


  #
  # PRE-PARSING (modes, modal arguments, modifiers)
  #
  local n
  for ((n=0;n<${#argstr};n++))
  do
    local ch=${argstr:$n:1}
    case "$ch" in

      # -- MODES --

      # No Colors MODE : strip all color info, whatever the result
      c)  forcenocolors="true"         ;;

      # Vim MODE : no color, prepend color infos for 'branch', use 'vimsplitsep' as separator
      v)
        forcenocolors="true"
        mode="VIM"
        # don't fucking change that:
        separator="vimsplitsep"

        #this was an annoying bug to correct: as VIM mode is used mostly with
        #the 'tartify v' command, then substituted with 'tartify vnbrsl', we are
        #in the case of a 'separator-less' tartify option string (separators
        #being characters which are not a tartify command). In this case,
        #forceseparator defaults to none. In this case, we need it to be TRUE

        forceSeparator=true
                                  ;;
      # Quiet mode (only update the __TART4PS1* variables)
      # ($tartanswer is discarded)
      q) mode="QUIET"
          #__t4_del=$__NN_
                                  ;;

      # PS1 mode (ansi color codes escaped with '\[' and '\]' for PS1
      p) mode="PS1"               ;;


      0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 )
          menuPos=$ch
                                  ;;
      # -- MODAL ARGS --
      m|M) includelocalpath="true" ;;


      r|R) processupstream="true"
            processremotes="true"  ;;

      b)    #no upstream calculation in branch with 't' (no upstream), 'c' (no color) and 'v' (VIM mode)
            [[ "$argstr" =~ v ]] || [[ "$argstr" =~ c ]] || [[ "$argstr" =~ t ]] ||  processupstream="true"
                                  ;;
      o)    #oldschool branch name
            #WARN: 1) this HAS to take place before calling __tartify_git_ps1_find_upstream
            #      2) any occurence of the 'b' option in the same tartify command will be treated as 'o'
        [ -n "${GIT_PS1_SHOWUPSTREAM-}" ] && processupstream="true"
        branchstyle="OLDSCHOOL"
                                  ;;
      #TODO:
      #l) #time since last commit
      #   [ -n "$TARTIFY_SETTING_TIME_BUGME" ] && processupstream="true"
      #                            ;;

      # -- MODIFIERS --
      t) processupstream="false"  ;;

      I) splitargstr=${argstr##*I}
        local ignoredpart=${argstr%%I*}
        #TODO: !!
         firstSplitDelimPos=$(echo "$ignoredpart" | tr -d $TARTIFY_OPTIONS)
         firstSplitDelimPos=${#firstSplitDelimPos}
                                  ;;
    esac
  done

  ## BAIL if 'I' is used in cunjunction with custom delimiters
  #[ -z "$splitargstr" ] || [ -z "$hasdelimiters" ] || {
  #    echo "ERROR: you cannot use the 'I' tartify option with custom delimiters"
  #    echo "splitargstr=$splitargstr - hasdelimiters=[$hasdelimiters]"
  #    return 1
  #}

  # -- PS1 building and exit --
  [[ "$argstr" =~ p ]] && { __tartify_build_PS1 $argstr; return 0; }


  # -- INIT PS1 dynamic variables --
  __tartify_reset_PS1_globs


  # -----------------------------------
  #           GIT REPO
  # -----------------------------------

  # -- BAIL if not INSIDE a GIT REPO --
  g=`git rev-parse --git-dir 2>/dev/null`
  [ $? -eq 0  ] && {



    #load optionnal ~/.tartifyrc config file
    # * if we're not in the middle of a tartitune session
    # * AND if we're not forcing tartify options ($TARTIFY_FORCE or 'f' option)
    [ "false" = $TARTITUNE_SETTING_FORCE ] && [ -z "$TARTIFY_FORCE" ] && [[ "$argstr" =~ f ]] && [ -f ~/.tartifyrc ] && . ~/.tartifyrc

    # PS1 tartiforce marker
    [ -n "$TARTIFY_FORCE" ] &&  __t4_force="!"

    #Perform some cheap 'git' tests (used in more than one '__tartify_*' function)

    localpath="$(pwd -P | tr -d '\n')"
    local localpath="$(pwd -P | tr -d '\n')"
    repopath="${g%%/.git}"
    [ ".git" = "$repopath" ] && repopath="$localpath"
    [ "." = "$repopath" ] && repopath="$localpath"
    reponame="${repopath##*/}"
    localpath="${localpath##$repopath}"

    isbare=$( git rev-parse --is-bare-repository 2>/dev/null )
    isinsideworktree=$(git rev-parse --is-inside-work-tree 2>/dev/null)
    if [ "true" = "$isinsideworktree" ]; then
      git rev-parse --verify refs/stash >/dev/null 2>&1 && hasstash="true"
    fi
    #TODO:UNUSED
    git rev-list  @{upstream}...HEAD >/dev/null 2>&1                  # 8ms
    [ $? -eq 0 ] && hasupstream="true" || hasupstream="false"




    #
    # PRE-PROCESSING
    #

    # fill $upstream if any
    [ "true" = "$processupstream" ] && __tartify_git_ps1_find_upstream

    # Fill in __git_ps1 locals
    __tartify_git_ps1

    #
    # PROCESSING
    #
    #TODO: cache already done calculations ? (tartify nb-n-b)
    #(might be totally stupid)
    local firstn="true" #don't insert separator before first item
    local delimNb=0     #delimiter's position
    tartanswer=""
    for ((n=0;n<${#argstr};n++))
    do
      # automatic separator in 'separator-less' tartify option string
      [ -z "$firstn" ] && [ ! -z "$forceSeparator" ] && tartanswer="$tartanswer$separator"

      nocolors="false"
      [ "true" = "$forcenocolors" ] && nocolors="true"

      local ch=${argstr:$n:1}
      case "$ch" in
        n | m)                  __tartify_repo_name      ;;
        a)                      __tartify_ancestor       ;;
        b)                      __tartify_branch         ;;
        o)     nocolors="true"; __tartify_branch         ;;
        r)                      __tartify_remote         ;;
        #TODO:
        s)                      __tartify_stash          ;;
        l)                      __tartify_timelastcommit ;;

        N | M) nocolors="true"; __tartify_repo_name      ;;
        A)     nocolors="true"; __tartify_ancestor       ;;
        B)     nocolors="true"; __tartify_branch         ;;
        R)     nocolors="true"; __tartify_remote         ;;
        #TODO:
        S)     nocolors="true"; __tartify_stash          ;;
        L)     nocolors="true"; __tartify_timelastcommit ;;
        0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 ) ;;
        I) ;;
        c) ;;
        d) ;;
        o) ;;
        p) ;;
        f) ;;
        i) ;;
        q) ;;
        t) ;;
        v) ;;
        w) ;;
        W) ;;
        *)
          local thisNb=$delimNb
          [ "true" = "$nocolors" ] && thisNb=$((delimNb + 50))
          [ -z "$splitargstr" ] && {
            #NO SPLIT OUTPUT
            tartanswer="$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_"
            [ " " = "$ch" ] && eval "__t4_D$thisNb=\" \"" || eval "__t4_D$thisNb=\"$ch\""

          } || {
            #SPLIT OUTPUT
            if [ $delimNb -lt $firstSplitDelimPos ]; then
              [ " " = "$ch" ] && eval "__t4_D$thisNb=\" \"" || eval "__t4_D$thisNb=\"$ch\""
            else
              tartanswer="$tartanswer$TARTIFY_COLOR_MISC_DELIMITER$ch$__NN_"
            fi
          }



          delimNb=$((delimNb + 1))
          ;;
      esac
      unset firstn
    done

    # Post Process

    # tartitune session
    [ "true" = $TARTITUNE_SETTING_FORCE ] && {
        tartanswer="$__EMR_*$__NN_$tartanswer"
        __t4_tune="*"
      } || {
        __t4_tune=
      }

    # VIM mode : remove first occurence of $separator
    [ "$mode" = "VIM" ] && tartanswer="${tartanswer/#vimsplitsep/}"

    # -- OUTPUT --

    # TODO: this test sucks (time lost in subshell)
    # remove ansi escapes
    local testforblank=$(printf "%s" "$tartanswer" | perl -pe 's/\e\[?.*?[\@-~]//g');
    #local testforblank=$(echo  "$tartanswer" | sed -E "s/\\\\033\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g")
    # variant : sed 's/\[[0-9;]*m//g'
    # variant2 : perl -pe 's/\e\[?.*?[\@-~]//g'
    #  (http://unix.stackexchange.com/questions/4527/program-that-passes-stdin-to-stdout-with-color-codes-stripped/4533#4533)

    testforblank=${testforblank/ //}

    # 1 - QUIET MODE
    if [ "QUIET" = "$mode" ]; then
      [ ${#testforblank} != 0 ] && {
        #note the 'whitespace' after the newline (needed for effective
        #newline in PS1)
        [[ "$argstr" =~ W ]] &&  __t4_newline_before=$(echo -ne "\n ")
        [[ "$argstr" =~ w ]] &&  __t4_newline_after=$(echo -ne "\n ")
      }
       return 0
    fi

    # 2 - MENU MODIFIER
    if [ ! -z $menuPos ]; then
      [ ${#testforblank} != 0 ] && {
          __tartify_popup
          #( __tartify_popup & )
      }
       return 0
    fi

    # 3 - OTHER MODEs
    # only do something if answer is not empty
    [ ${#testforblank} != 0 ] && {
      [[ "$argstr" =~ W ]] && echo -ne "\n" # linebreak before
      printf "%s" "$tartanswer"
      [[ "$argstr" =~ w ]] && echo -ne "\n" # linebreak after
    }

  } || {

  # -----------------------------------
  #           *NOT* a GIT REPO
  # -----------------------------------
    #Not a GIT repo, echo $PWD if 'd' option
    [[ "$argstr" =~ d ]] && {
        if [[ "$argstr" =~ q ]] || [[ "$argstr" =~ I ]]; then
          __t4_pwd=$(__tartify_smart_PWD)
        else
            printf "%s" "$TARTIFY_COLOR_PWD$(__tartify_smart_PWD)$_NN_"
        fi
    }
  }

  return 0
}


#------------------------------------------------------------------------------
#
#             TARTIFY ADDONS
#
#------------------------------------------------------------------------------

tartiforce(){
  # force tartify options (ignores .tartifyrc, replaces command line arguments
  #                        to tartify from now on, until ended)

  [ -z "$*" ] && {
  #      echo "
  #leaving the tarti${__EMR_}force${__NN_} !
  #      "
        TARTIFY_FORCE=
    } || {
      case "$*" in
        h | -h | \? | -\?)
          echo "
  ${__EMR_}tartiforce${__NN_} : 
          ${__EMY_}argstring${__NN_}   force tartify settings
          ${__EMY_}empty${__NN_}       unforce tartify settings
          "
          ;;
        *)
  #        echo "
  #joining the tarti${__EMR_}force${__NN_} with ${__EMY_}$*${__NN_}
  #        "
          TARTIFY_FORCE="$*"
          ;;
      esac
    }
}

#TODO: tartitune (noargs) ends with a notification if we're in a tartitune session
tartitune(){
  # Quick tuner for tartify's COLOR/STYLE/STRING/SETTING-RELATED environment variables
  # (with completion)

  #save tartify() environment before beginning a tartitune session
  __tartitune_save_groundzero

  local myargs=$(echo "$*" | tr '[A-Z]' '[a-z]' | tr '-' ' ' | sed 's/tartify_//g')
  [ -z "$myargs" ] && { __tartify_show_env ; return 0; }
  local myansw
  local string_or_setting
  local action
  local myarg
  local myenv
  local testmode

  # ----------------------------
  # Parse command line options
  # ----------------------------
  for myarg in $myargs; do
    case $myarg in

      # ENV VARS
      style_*|color_*) myenv="$myenv$myarg "
                                       ;;
      test)     testmode="true"           ;;

      # STYLES
      bold|emphasized)   myansw=$myansw$__EM_ ;;  underlined)        myansw=$myansw$__UN_ ;;
      inverse|reverse)        myansw=$myansw$__RV_  ;;

      # COLORS
      black)     myansw=$myansw$__K_   ;;  red)        myansw=$myansw$__R_  ;;
      green)     myansw=$myansw$__G_   ;;  yellow)     myansw=$myansw$__Y_  ;;
      blue)      myansw=$myansw$__B_   ;;  magenta)    myansw=$myansw$__M_  ;;
      cyan)      myansw=$myansw$__C_   ;;  white)      myansw=$myansw$__W_  ;;

      # BACKGROUND COLORS
      bgblack)   myansw=$myansw$__BGK_ ;;  bgred)      myansw=$myansw$__BGR_;;
      bggreen)   myansw=$myansw$__BGG_ ;;  bgyellow)   myansw=$myansw$__BGY_;;
      bgblue)    myansw=$myansw$__BGB_ ;;  bgmagenta)  myansw=$myansw$__BGM_;;
      bgcyan)    myansw=$myansw$__BGC_ ;;  bgwhite)    myansw=$myansw$__BGW_;;

      # SETTINGS
      bugme)     string_or_setting="b"  ;;
      timelong)  string_or_setting="L"  ;;
      timeshort) string_or_setting="S"  ;;
      timechar)  string_or_setting="C"  ;;

      # MISC
      export)    action="e"            ;;
      quit)      action="q"            ;;
      last)      action="l"            ;;
      nuke)      action="n"            ;;

      # HELP
      h|help|?) __tartify_usage "__tartitune_Helpmsg"
        return 0                      ;;

     *) echo "Unknown argument $myarg"
        return 1
                                      ;;
    esac
  done;

  # ----------------------------
  # Avoid Conflicting options
  # ----------------------------
  #
  local conflictingOptions=0
  [ -z "$action" ] || conflictingOptions=$(($conflictingOptions + 1))
  [ -z "$string_or_setting" ] || conflictingOptions=$(($conflictingOptions + 1))


  if [ -n $myenv ]; then :
  elif [ -n $myansw ]; then :
  else 
    conflictingOptions=$(($conflictingOptions + 1))
  fi

  # -- BAIL if conflicting options --
  [ 1 -lt $conflictingOptions ] && {
    echo "
${__EMR}ERROR${__NN_}: you cannot use ${__EMG_}compound${__NN_} colors, ${__EMG_}string_or_setting${__NN_} and/or ${__EMG_}action${__NN_} options at the same time 
"
    return 1
  }

  # ----------------------------
  #    COMPOUND (colors)
  # ----------------------------
  if [ ! -z "$myenv" ] || [ ! -z "$myansw" ]; then
    [ -n "$myenv" ] && {
          # WITH ENV
          local thisenv
          for thisenv in $myenv; do
              thisenvUP="TARTIFY_"$(echo $thisenv | tr '[a-z]' '[A-Z]')
              [ -n "$myansw" ] && {
                  printf "\n%s" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")was$__NN_)"
                  [ "true" = "$testmode" ] && printf " %s\n" " (${myansw}*TEST*$__NN_)"|| {
                      printf " %s\n" " (${myansw}now is$__NN_)"
                      #ASSIGN env variable
                      eval "$thisenvUP=$myansw"
                      TARTITUNE_SETTING_FORCE="true"
                  }
              } || {
                  printf "\n%s\n" "no option set."
                  printf "%s\n" "$thisenvUP ($(eval printf "%s" "\$$thisenvUP")is$__NN_)"
              }
          done
          echo
    } || {
        # NO ENV
        [ "true" = "$testmode" ] && printf "%s\n" "${myansw}*TEST*$__NN_" ||
          printf "%s" "${myansw}"
    }
  # ----------------------------
  #           ACTION
  # ----------------------------
  elif [ ! -z "$action" ]; then
    case $action in

      #export
      e)
          env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" | sort > ~/.tartitunebak
          echo "current$__EMR_ tartify$__NN_ environment exported to ~/.tartunebak"
          ;;

      #nuke : save current in ~/.tartifyrc
      n)
          TARTITUNE_SETTING_FORCE="false"
          #save tartify() environment before beginning a tartitune session
          [ -f "$TMPDIR/tartitune_setting_last" ] && {
            if __tartitune_check_tmpdir;then
              rm -f "$TMPDIR/tartitune_setting_last"
              #env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" >$TMPDIR/tartitune_setting_groundzero
            fi
          }
          #TARTITUNE_SETTING_LAST=""

          __tartitune_save_groundzero

          env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" | sort > ~/.tartifyrc
          echo "current$__EMR_ tartify$__NN_ environment exported to ~/.tartifyrc"
          return 0
          ;;

      #quit : exit without saving, revert to original env
      q)
          TARTITUNE_SETTING_FORCE="false"
          __tartitune_save_current
          [ -f "$TMPDIR/tartitune_setting_groundzero" ] && eval $( cat "$TMPDIR/tartitune_setting_groundzero")
          __tartitune_erase_groundzero

          echo "exiting$__EMR_ tartitune$__NN_ session, modified environment discarded
          (use 'tartitune last' to restore)"
          return 0
          ;;

      #restore last
      l)
          [ -f "$TMPDIR/tartitune_setting_last" ] && eval $( cat "$TMPDIR/tartitune_setting_last")
          TARTITUNE_SETTING_FORCE="true";
          ;;
    esac
  # ----------------------------
  #    STRING_OR_SETTING
  # ----------------------------
  else
    case $string_or_setting in

      b)  [ -z "$TARTIFY_SETTING_TIME_BUGME" ] && {
          TARTIFY_SETTING_TIME_BUGME="TRUE"
          TARTITUNE_SETTING_FORCE="true"
          echo "time display ${__EMG_}will include${__NN_} ${TARTIFY_STYLE_TIME_COULDCOMMIT}could${__NN_}/${TARTIFY_STYLE_TIME_SHOULDCOMMIT}should${__NN_} commit styles"
        } || {
          TARTIFY_SETTING_TIME_BUGME=
          TARTITUNE_SETTING_FORCE="true"
          echo "time display ${__EMR_}won't include${__NN_} ${TARTIFY_STYLE_TIME_COULDCOMMIT}could${__NN_}/${TARTIFY_STYLE_TIME_SHOULDCOMMIT}should${__NN_} commit styles"
      }
          ;;
      L)  TARTIFY_SETTING_TIME_DISPLAY="LONG"
          TARTITUNE_SETTING_FORCE="true"
          echo "time display set to ${__EMG_}LONG${__NN_}"
          ;;
      S)  TARTIFY_SETTING_TIME_DISPLAY="SHORT"
          TARTITUNE_SETTING_FORCE="true"
          echo "time display set to ${__EMG_}SHORT${__NN_}"
          ;;
      C)  TARTIFY_SETTING_TIME_DISPLAY="CHAR"
          TARTITUNE_SETTING_FORCE="true"
          echo "time display set to ${__EMG_}CHAR${__NN_}"
          ;;
    esac
  fi

  # ----------------------------
  #    save current settings
  # ----------------------------
  __tartitune_save_current

}


__tartitune_save_current(){

  [ -f "$TMPDIR/tartitune_setting_last" ] || {
    if __tartitune_check_tmpdir;then
      env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" >$TMPDIR/tartitune_setting_last
    fi
  }

}


__tartitune_save_groundzero(){

  [ -f "$TMPDIR/tartitune_setting_groundzero" ] || {
    if __tartitune_check_tmpdir;then
      env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" >$TMPDIR/tartitune_setting_groundzero
    fi
  }

}


__tartitune_erase_groundzero(){

  [ -f "$TMPDIR/tartitune_setting_groundzero" ] && {
    if __tartitune_check_tmpdir;then
      rm -f "$TMPDIR/tartitune_setting_groundzero" 
      #env | grep "^TARTIFY_\(COLOR\|STRING\|STYLE\|SETTING\)" >$TMPDIR/tartitune_setting_groundzero
    fi
  }

}


__tartitune_completion()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    optsVARLONG="${!TARTIFY_COLOR*} ${!TARTIFY_STYLE*}"
    optsVAR=$( echo $optsVARLONG |  sed 's/TARTIFY_/-/g')
    ## Slower
    #optsVAR=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("-%s ", $1)}' | sed 's/TARTIFY_//g')
    #optsVARLONG=$(env | grep "^TARTIFY_COLOR\|^TARTIFY_STYLE" | awk -F"=" '{printf("%s ", $1)}')

    optsARG="bold emphasized underlined inverse reverse black red green yellow
    blue magenta cyan white bgblack bgred bggreen bgyellow bgblue
    bgmagenta bgcyan bgwhite quit nuke last test export help bugme
    timelong timeshort timechar"

    #if [[ ${cur} == T* ]] ; then
    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVAR}" -- ${cur}) )
        return 0
    elif [[ ${cur} == T* ]] ; then
        COMPREPLY=( $(compgen -W "${optsVARLONG}" -- ${cur}) )
        return 0
    else
        COMPREPLY=( $(compgen -W "${optsARG}" -- ${cur}) )
        return 0
    fi
}


__tartitune_check_tmpdir(){
  [ -z ${TMPDIR:-} ] && {
    echo "\$TMPDIR environment variable empty. Cannot proceed. Aborted"
    return 1
  } || {
      [ -w $TMPDIR ] && return 0 || {
        echo "\$TMPDIR directory '$TMPDIR' is not writeable. Cannot proceed. Aborted"
        return 1
      }
  }
}


#------------------------------------------------------------------------------
#
#             MAIN
#
#------------------------------------------------------------------------------

__tartify_define_colors_TPUT
__tartify_reset_PS1_globs
__tartify_init_globs
__tartitune_init_globs
[ -f ~/.tartifyrc ] && . ~/.tartifyrc

# ADDONS

##TODO: ZSH compatibility
#if [[ -n ${ZSH_VERSION-} ]]; then
#  autoload -U compinit
#fi
#
#if [[ -n ${ZSH_VERSION-} ]]; then
#  emulate -L bash
#  setopt KSH_TYPESET
#
#  # workaround zsh's bug that leaves 'words' as a special
#  # variable in versions < 4.3.12
#  typeset -h words
#fi

complete -F __tartitune_completion tartitune


# script is being executed, run the main command
# script is being sourced, exit with 0
[ "$__tartify_whocalled" = "exec" ] && tartify $__tartify_args || return 0

